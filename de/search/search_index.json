{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"English \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Deutsch \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Fran\u00e7ais Espa\u00f1ol"},{"location":"#einfuhrung","title":"Einf\u00fchrung","text":"<p>Die TRegExpr-Bibliothek implementiert regul\u00e4re Ausdr\u00fccke.</p> <p>Regul\u00e4re Ausdr\u00fccke sind ein einfach zu benutzendes und leistungsf\u00e4higes Werkzeug f\u00fcr komplexe Such- und Ersetzungsoperationen sowie f\u00fcr die \u00dcberpr\u00fcfung von Texten anhand von Vorlagen.</p> <p>Sie sind besonders n\u00fctzlich f\u00fcr die Validierung von Benutzereingaben in Formularen - zum Validieren von E-Mail-Adressen und so weiter.</p> <p>Au\u00dferdem k\u00f6nnen Sie Telefonnummern, Postleitzahlen usw. von Webseiten oder Dokumenten extrahieren, nach komplexen Mustern in Logdateien suchen und alles, was Sie sich vorstellen k\u00f6nnen. Regeln (Vorlagen) k\u00f6nnen ge\u00e4ndert werden, ohne Ihr Programm neu kompilieren zu m\u00fcssen.</p> <p>TRegExpr ist in reinem Pascal implementiert. Es ist in Lazarus (Free Pascal) enthalten:  Paket.  Aber es existiert auch als separate Bibliothek und kann mit Delphi 2-7, Borland C++ Builder 3-6 kompiliert werden.</p> <p>Wie gut die Bibliothek aufgenommen wurde.</p>"},{"location":"#schnellstart","title":"Schnellstart","text":"<p>Um die Bibliothek zu verwenden, f\u00fcgen Sie einfach die Quellen zu Ihrem Projekt hinzu und verwenden Sie die Klasse TRegExpr.</p> <p>Im FAQ k\u00f6nnen Sie von den Problemen anderer Benutzer lernen.</p> <p>Die sofort einsatzbereite Windows-Anwendung REStudio hilft Ihnen, regul\u00e4re Ausdr\u00fccke zu lernen und zu debuggen.</p> <p>Wenn Sie Probleme sehen, bitte erstellen Sie ein Ticket.</p>"},{"location":"#ubersetzungen","title":"\u00dcbersetzungen","text":"<p>Die Dokumentation wurde ins Englische und Russische \u00fcbersetzt.</p> <p>Es gibt unvollst\u00e4ndige \u00dcbersetzungen in mehrere andere Sprachen. Wenn Sie helfen m\u00f6chten, sie zu vervollst\u00e4ndigen, kontaktieren Sie mich.</p>"},{"location":"#dankbarkeit","title":"Dankbarkeit","text":"<p>Viele Funktionen wurden vorgeschlagen und viele Fehler gefunden (und sogar behoben) von den Beitragenden von TRegExpr.</p> <p>Ich kann hier nicht alle auflisten, aber ich sch\u00e4tze alle Fehlerberichte, Funktionsvorschl\u00e4ge und Fragen, die ich von Ihnen erhalte.</p> <ul> <li>Alexey Torgashin - Hauptbeitragender seit 2019, z.B.</li> <li>benannte Gruppen, nicht erfassende Gruppen, Behauptungen, r\u00fcckw\u00e4rtige Suche und vieles mehr</li> <li>Guido Muehlwitz - fand und korrigierte einen schweren Fehler bei der Verarbeitung gro\u00dfer Zeichenketten</li> <li>Stephan Klimek - Testen in C++Builder und Vorschlagen/Implementieren   vieler Funktionen</li> <li>Steve Mudford - implementierte den Offset-Parameter</li> <li>Martin Baur (www.mindpower.com) - deutsche   \u00dcbersetzung, n\u00fctzliche Vorschl\u00e4ge</li> <li>Yury Finkel - implementierte Unicode-Unterst\u00fctzung, fand und korrigierte einige Fehler</li> <li>Ralf Junker - implementierte einige Funktionen, viele Optimierungsvorschl\u00e4ge</li> <li>Simeon Lilov - Bulgarische \u00dcbersetzung</li> <li>Filip Jirs\u0431k und Matthew Winter - Hilfe bei der Implementierung des nicht gierigen   Modus</li> <li>Kit Eason - viele Beispiele f\u00fcr den Einf\u00fchrungshilfeabschnitt</li> <li>Juergen Schroth - Fehlersuche und n\u00fctzliche Vorschl\u00e4ge</li> <li>Martin Ledoux - Franz\u00f6sische \u00dcbersetzung</li> <li>Diego Calp, Argentinien - Spanische \u00dcbersetzung</li> </ul>"},{"location":"demos/","title":"Demos","text":"<p>Demo-Code f\u00fcr TRegExpr</p>"},{"location":"demos/#einfuhrung","title":"Einf\u00fchrung","text":"<p>If you don't familiar with regular expression, please, take a look at the r.e.syntax.</p> <p>TRegExpr interface described in TRegExpr interface.</p>"},{"location":"demos/#text2html","title":"Text2HTML","text":"<p>`Text2HTML-Quellen \\&lt;https://github.com/andgineer/TRegExpr/tree/master/examples/Text2HTML&gt; _</p> <p>Ver\u00f6ffentlichen Sie Nur-Text als HTML</p> <p>Uses unit HyperLinksDecorator that is based on TRegExpr. \u00a0 Diese Einheit enth\u00e4lt Funktionen zum Verzieren von Hyperlinks.</p> <p>For example, replaces <code>www.sorokin.engineer</code> with <code>&lt;a href=\"http://www.sorokin.engineer\"&gt;www.sorokin.engineer&lt;/a&gt;</code> or <code>filbert@yandex.ru</code> with <code>&lt;a href=\"mailto:filbert@yandex.ru\"&gt;filbert@yandex.ru&lt;/a&gt;</code>. \u00a0 .. code-block:: pascal</p> <p>function DecorateURLs ( const AText : string; AFlags : TDecorateURLsFlagSet = [durlAddr, DurlPath]</p> <p>) : string;</p> <p>type TDecorateURLsFlags = ( durlProto, durlAddr, durlPort, DurlPath, durlBMark, DurlParam);</p> <p>TDecorateURLsFlagSet = set of TDecorateURLsFlags;</p> <p>function DecorateEMails (const AText : string) : string; \u00a0</p> Wert B edeutung durlProto Protokoll (wie ` ftp: // `oder http: // `) durlAddr \u00a0 TCP-Adresse oder Dom\u00e4nenname (wie <code>sorokin.engineer</code>) durlPort \u00a0 Portnummer, falls angegeben (wie <code>: 8080</code>) DurlPath \u00a0 Pfad zum Dokument (wie <code>index.html</code>) durlBMark Buchmarke (wie <code>#mark</code>) DurlParam URL-Parameter (wie <code>? ID = 2 &amp;amp; User = 13</code>) <p>Gibt den eingegebenen Text \"AText\" mit verzierten Hyperlinks zur\u00fcck.</p> <p><code>AFlags</code> describes, which parts of hyper-link must be included into visible part of the link.</p> <p>For example, if AFlags is <code>[durlAddr]</code> then hyper link <code>www.sorokin.engineer/contacts.htm</code> will be decorated as <code>&lt;a href=\"www.sorokin.engineer/contacts.htm\"&gt;www.sorokin.engineer&lt;/a&gt;</code>.</p>"},{"location":"demos/#tregexprroutines-httpsgithubcomandgineertregexprtreemasterexamplestregexprroutines-_","title":"`TRegExprRoutines \\&lt;https://github.com/andgineer/TRegExpr/tree/master/examples/TRegExprRoutines&gt; _","text":"<p>Sehr einfache Beispiele, siehe Kommentare im Ger\u00e4t</p>"},{"location":"demos/#tregexprclass-httpsgithubcomandgineertregexprtreemasterexamplestregexprclass-_","title":"`TRegExprClass \\&lt;https://github.com/andgineer/TRegExpr/tree/master/examples/TRegExprClass&gt; _","text":"<p>Etwas komplexere Beispiele, siehe Kommentare innerhalb der Einheit</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#ich-habe-einen-schrecklichen-fehler-gefunden-tregexpr-verursacht-eine-zugriffsverletzungs-ausnahme","title":"Ich habe einen schrecklichen Fehler gefunden: TRegExpr verursacht eine Zugriffsverletzungs-Ausnahme!","text":"<p>Antwort</p> <p>Sie m\u00fcssen das Objekt vor der Verwendung erstellen. Also, nachdem Sie etwas wie folgt deklariert haben:</p> <pre><code>r : TRegExpr\n</code></pre> <p>vergessen Sie nicht, die Objektinstanz zu erstellen:</p> <pre><code>r := TRegExpr.Create.\n</code></pre>"},{"location":"faq/#unterstutzt-es-unicode","title":"Unterst\u00fctzt es Unicode?","text":"<p>Antwort</p> <p>Wie man Unicode verwendet</p>"},{"location":"faq/#warum-gibt-tregexpr-mehr-als-eine-zeile-zuruck","title":"Warum gibt TRegExpr mehr als eine Zeile zur\u00fcck?","text":"<p>Zum Beispiel gibt das r.e. <code>&lt;font .\\*&gt;</code> den ersten <code>&lt;font</code> zur\u00fcck, dann den Rest der Datei einschlie\u00dflich des letzten <code>&lt;/html&gt;</code>.</p> <p>Antwort</p> <p>Aus Gr\u00fcnden der Abw\u00e4rtskompatibilit\u00e4t ist der Modifikator /s standardm\u00e4\u00dfig eingeschaltet.</p> <p>Schalten Sie ihn aus und <code>.</code> wird alles au\u00dfer Zeilentrennern entsprechen - genau wie Sie es w\u00fcnschen.</p> <p>\u00dcbrigens schlage ich <code>&lt;font ([^\\n&gt;]*)&gt;</code> vor, in <code>Match[1]</code> wird die URL sein.</p>"},{"location":"faq/#warum-gibt-tregexpr-mehr-zuruck-als-ich-erwarte","title":"Warum gibt TRegExpr mehr zur\u00fcck, als ich erwarte?","text":"<p>Zum Beispiel gibt das r.e. <code>&lt;p&gt;(.+)&lt;/p&gt;</code> angewandt auf den String <code>&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;</code> <code>a&lt;/p&gt;&lt;p&gt;b</code> zur\u00fcck, aber nicht <code>a</code>, wie ich erwartet h\u00e4tte.</p> <p>Antwort</p> <p>Standardm\u00e4\u00dfig arbeiten alle Operatoren im \u201egierigen\u201c Modus, sodass sie so viel wie m\u00f6glich entsprechen.</p> <p>Wenn Sie den \u201enicht gierigen\u201c Modus m\u00f6chten, k\u00f6nnen Sie \u201enicht gierige\u201c Operatoren wie <code>+?</code> usw. verwenden oder alle Operatoren mit Hilfe des Modifikators <code>g</code> in den \u201enicht gierigen\u201c Modus umschalten (verwenden Sie entsprechende TRegExpr-Eigenschaften oder den Operator <code>?(-g)</code> in r.e.).</p>"},{"location":"faq/#wie-kann-man-quellen-wie-html-mit-hilfe-von-tregexpr-parsen","title":"Wie kann man Quellen wie HTML mit Hilfe von TRegExpr parsen?","text":"<p>Antwort</p> <p>Entschuldigung, Leute, aber das ist nahezu unm\u00f6glich!</p> <p>Nat\u00fcrlich k\u00f6nnen Sie TRegExpr leicht verwenden, um einige Informationen aus HTML zu extrahieren, wie in meinen Beispielen gezeigt, aber wenn Sie ein genaues Parsing m\u00f6chten, m\u00fcssen Sie einen echten Parser verwenden, nicht r.e.</p> <p>Eine vollst\u00e4ndige Erkl\u00e4rung k\u00f6nnen Sie zum Beispiel im <code>Perl Cookbook</code> von Tom Christiansen und Nathan Torkington nachlesen.</p> <p>Kurz gesagt - es gibt viele Strukturen, die leicht von einem echten Parser analysiert werden k\u00f6nnen, aber \u00fcberhaupt nicht von r.e., und ein echter Parser ist viel schneller beim Parsen, weil r.e. nicht einfach den Eingabestrom scannt, sondern eine Optimierungssuche durchf\u00fchrt, die viel Zeit in Anspruch nehmen kann.</p>"},{"location":"faq/#gibt-es-eine-moglichkeit-mehrere-ubereinstimmungen-eines-musters-bei-tregexpr-zu-erhalten","title":"Gibt es eine M\u00f6glichkeit, mehrere \u00dcbereinstimmungen eines Musters bei TRegExpr zu erhalten?","text":"<p>Antwort</p> <p>Sie k\u00f6nnen \u00dcbereinstimmungen mit der Methode ExecNext iterieren.</p> <p>Wenn Sie ein Beispiel m\u00f6chten, schauen Sie sich bitte die Implementierung der Methode <code>TRegExpr.Replace</code> an oder die Beispiele f\u00fcr HyperLinksDecorator</p>"},{"location":"faq/#ich-uberprufe-benutzereingaben-warum-gibt-tregexpr-true-fur-falsche-eingabestrings-zuruck","title":"Ich \u00fcberpr\u00fcfe Benutzereingaben. Warum gibt TRegExpr <code>True</code> f\u00fcr falsche Eingabestrings zur\u00fcck?","text":"<p>Antwort</p> <p>In vielen F\u00e4llen vergessen TRegExpr-Benutzer, dass der regul\u00e4re Ausdruck f\u00fcr die Suche im Eingabestring vorgesehen ist.</p> <p>Also, wenn Sie zum Beispiel den Ausdruck <code>\\d{4,4}</code> verwenden, werden Sie Erfolg haben bei falschen Benutzereingaben wie <code>12345</code> oder <code>beliebige Buchstaben 1234</code>.</p> <p>Sie m\u00fcssen vom Zeilenanfang bis zum Zeilenende pr\u00fcfen, um sicherzustellen, dass nichts anderes drum herum ist: <code>^\\d{4,4}$</code>.</p>"},{"location":"faq/#warum-funktionieren-nicht-gierige-iteratoren-manchmal-wie-im-gierigen-modus","title":"Warum funktionieren nicht-gierige Iteratoren manchmal wie im gierigen Modus?","text":"<p>Zum Beispiel entspricht das r.e. <code>a+?,b+?</code> angewandt auf den String <code>aaa,bbb</code> <code>aaa,b</code>, aber sollte es nicht <code>a,b</code> entsprechen wegen der Nicht-Gierigkeit des ersten Iterators?</p> <p>Antwort</p> <p>Dies liegt an der Arbeitsweise von TRegExpr. Tats\u00e4chlich arbeiten viele andere r.e. Engines genau gleich: Sie f\u00fchren nur eine \u201eeinfache\u201c Suchoptimierung durch und versuchen nicht, die beste Optimierung zu finden.</p> <p>In einigen F\u00e4llen ist das schlecht, aber im Allgemeinen ist es eher ein Vorteil als eine Einschr\u00e4nkung, aus Gr\u00fcnden der Leistung und Vorhersagbarkeit.</p> <p>Die Hauptregel - r.e. versucht zuerst, vom aktuellen Ort aus zu entsprechen und nur, wenn das v\u00f6llig unm\u00f6glich ist, bewegt es sich um ein Zeichen vorw\u00e4rts und versucht es erneut von der n\u00e4chsten Position im Text.</p> <p>Also, wenn Sie <code>a,b+?</code> verwenden, wird es <code>a,b</code> entsprechen. Im Falle von <code>a+?,b+?</code> ist es jetzt nicht empfohlen (wir haben den nicht-gierigen Modifikator hinzugef\u00fcgt), aber es ist immer noch m\u00f6glich, mehr als ein <code>a</code> zu entsprechen, also wird TRegExpr es tun.</p> <p>TRegExpr wie Perl oder Unix r.e. versucht nicht, vorw\u00e4rts zu bewegen und zu pr\u00fcfen - w\u00e4re es eine \"bessere\" \u00dcbereinstimmung. Vor allem, weil es keinen Weg gibt zu sagen, dass eine \u00dcbereinstimmung besser oder schlechter ist.</p>"},{"location":"faq/#wie-kann-ich-tregexpr-mit-borland-c-builder-verwenden","title":"Wie kann ich TRegExpr mit Borland C++ Builder verwenden?","text":"<p>Ich habe ein Problem, da keine Header-Datei (<code>.h</code> oder <code>.hpp</code>) verf\u00fcgbar ist.</p> <p>Antwort</p> <ul> <li>F\u00fcgen Sie <code>RegExpr.pas</code> zum <code>bcb</code>-Projekt hinzu.</li> <li>Kompilieren Sie das Projekt. Dies generiert die Header-Datei <code>RegExpr.hpp</code>.</li> <li>Jetzt k\u00f6nnen Sie Code schreiben, der die Einheit <code>RegExpr</code> verwendet.</li> <li>Vergessen Sie nicht, <code>#include \u201cRegExpr.hpp\u201d</code> hinzuzuf\u00fcgen, wo es ben\u00f6tigt wird.</li> <li>Vergessen Sie nicht, alle <code>\\</code> in regul\u00e4ren Ausdr\u00fccken mit <code>\\\\</code> zu ersetzen oder die Konstante EscChar neu zu definieren.</li> </ul>"},{"location":"faq/#warum-funktionieren-viele-re-einschlielich-re-aus-der-hilfe-und-demo-von-tregexpr-falsch-in-borland-c-builder","title":"Warum funktionieren viele r.e. (einschlie\u00dflich r.e. aus der Hilfe und Demo von TRegExpr) falsch in Borland C++ Builder?","text":"<p>Antwort</p> <p>Der Hinweis ist in der vorherigen Frage ;) Das Symbol <code>\\</code> hat eine besondere Bedeutung in <code>C++</code>, daher m\u00fcssen Sie es \u201eescapen\u201c (wie in der vorherigen Antwort beschrieben). Aber wenn Sie r.e. wie <code>\\\\w+\\\\w+\\\\.\\\\w+</code> nicht m\u00f6gen, k\u00f6nnen Sie die Konstante <code>EscChar</code> (in <code>RegExpr.pas</code>) neu definieren. Zum Beispiel <code>EscChar = \"/\"</code>. Dann k\u00f6nnen Sie <code>/w+/w+/./w+</code> schreiben, sieht ungew\u00f6hnlich aus, aber lesbarer.</p>"},{"location":"regular_expressions/","title":"Regul\u00e4re Ausdr\u00fccke (RegEx)","text":""},{"location":"regular_expressions/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Regul\u00e4re Ausdr\u00fccke sind eine praktische Methode, um Muster in Texten zu definieren.</p> <p>Mit regul\u00e4ren Ausdr\u00fccken kannst du Benutzereingaben validieren, nach Mustern wie E-Mails oder Telefonnummern auf Webseiten oder in Dokumenten suchen und vieles mehr.</p> <p>Unten findest du das komplette Cheat Sheet f\u00fcr regul\u00e4re Ausdr\u00fccke.</p>"},{"location":"regular_expressions/#zeichen","title":"Zeichen","text":""},{"location":"regular_expressions/#einfache-ubereinstimmungen","title":"Einfache \u00dcbereinstimmungen","text":"<p>Jedes einzelne Zeichen (au\u00dfer speziellen RegEx-Zeichen) entspricht sich selbst. Eine Reihe von (nicht speziellen) Zeichen entspricht dieser Reihe von Zeichen im Eingabestring.</p> RegEx Entsprechungen <code>foobar</code> <code>foobar</code>"},{"location":"regular_expressions/#nicht-druckbare-zeichen-escape-codes","title":"Nicht-druckbare Zeichen (Escape-Codes)","text":"<p>Um ein Zeichen durch seinen Unicode-Code zu spezifizieren, verwende das Pr\u00e4fix <code>\\x</code> gefolgt von dem Hex-Code. F\u00fcr 3-4 stellige Codes (nach U+00FF), schlie\u00dfe den Code in Klammern ein.</p> RegEx Entsprechungen <code>\\xAB</code> Zeichen mit 2-stelligem Hex-Code <code>AB</code> <code>\\x{AB20}</code> Zeichen mit 1..4-stelligem Hex-Code <code>AB20</code> <code>foo\\x20bar</code> <code>foo bar</code> (beachte Leerzeichen in der Mitte) <p>Es gibt eine Anzahl vordefinierter Escape-Codes f\u00fcr nicht-druckbare Zeichen, \u00e4hnlich wie in der C-Sprache:</p> RegEx Entsprechungen <code>\\t</code> Tabulator (HT/TAB), wie <code>\\x09</code> <code>\\n</code> Zeilenvorschub (LF), wie <code>\\x0a</code> <code>\\r</code> Wagenr\u00fccklauf (CR), wie <code>\\x0d</code> <code>\\f</code> Seitenvorschub (FF), wie <code>\\x0c</code> <code>\\a</code> Alarm (BEL), wie <code>\\x07</code> <code>\\e</code> Escape (ESC), wie <code>\\x1b</code> <code>\\cA</code> ... <code>\\cZ</code> chr(0) bis chr(25). Zum Beispiel entspricht <code>\\cI</code> dem Tabulator-Zeichen. Kleinbuchstaben \"a\"...\"z\" werden ebenfalls unterst\u00fctzt."},{"location":"regular_expressions/#escaping","title":"Escaping","text":"<p>Um ein spezielles RegEx-Zeichen (eines von <code>.+*?|\\()[]{}^$</code>) darzustellen, setze einen Backslash <code>\\</code> davor. Der Backslash muss ebenfalls escaped werden.</p> RegEx Entsprechungen <code>\\^FooBarPtr</code> <code>^FooBarPtr</code>, dies ist <code>^</code> und nicht Anfang der Zeile <code>\\[a\\]</code> <code>[a]</code>, dies ist keine Zeichenklasse"},{"location":"regular_expressions/#zeichenklassen","title":"Zeichenklassen","text":""},{"location":"regular_expressions/#benutzerdefinierte-zeichenklassen","title":"Benutzerdefinierte Zeichenklassen","text":"<p>Eine Zeichenklasse ist eine Liste von Zeichen innerhalb eckiger Klammern <code>[]</code>. Die Klasse entspricht jedem einzelnen Zeichen, das in dieser Klasse aufgelistet ist.</p> RegEx Entsprechungen <code>foob[aeiou]r</code> <code>foobar</code>, <code>foober</code> usw., aber nicht <code>foobbr</code>, <code>foobcr</code> <p>Du kannst die Klasse \"invertieren\" - wenn das erste Zeichen nach der <code>[</code> ein <code>^</code> ist, dann entspricht die Klasse jedem Zeichen au\u00dfer den in der Klasse aufgelisteten Zeichen.</p> RegEx Entsprechungen <code>foob[^aeiou]r</code> <code>foobbr</code>, <code>foobcr</code> usw., aber nicht <code>foobar</code>, <code>foober</code> <p>Innerhalb einer Liste wird das Minuszeichen <code>-</code> verwendet, um einen Bereich anzugeben, sodass <code>a-z</code> alle Zeichen zwischen <code>a</code> und <code>z</code> einschlie\u00dflich darstellt.</p> <p>Wenn du das Minuszeichen <code>-</code> selbst als Mitglied einer Klasse haben m\u00f6chtest, setze es an den Anfang oder das Ende der Liste oder escape es mit einem Backslash.</p> <p>Wenn du <code>]</code> als Teil der Klasse haben m\u00f6chtest, kannst du es am Anfang der Liste platzieren oder escape es mit einem Backslash.</p> RegEx Entsprechungen <code>[-az]</code> <code>a</code>, <code>z</code> und <code>-</code> <code>[az-]</code> <code>a</code>, <code>z</code> und <code>-</code> <code>[a\\-z]</code> <code>a</code>, <code>z</code> und <code>-</code> <code>[a-z]</code> Zeichen von <code>a</code> bis <code>z</code> <code>[\\n-\\x0D]</code> Zeichen von chr(10) bis chr(13)"},{"location":"regular_expressions/#punkt-meta-zeichen","title":"Punkt-Meta-Zeichen","text":"<p>Das Meta-Zeichen <code>.</code> (Punkt) entspricht standardm\u00e4\u00dfig jedem Zeichen. Aber wenn du den Modifikator /s ausschaltest, entspricht es nicht Zeilenumbruch-Zeichen.</p> <p>Der <code>.</code> fungiert nicht als Meta-Klasse innerhalb benutzerdefinierter Zeichenklassen. <code>[.]</code> bedeutet einen w\u00f6rtlichen \".\".</p>"},{"location":"regular_expressions/#meta-klassen","title":"Meta-Klassen","text":"<p>Es gibt eine Reihe vordefinierter Zeichenklassen, die regul\u00e4re Ausdr\u00fccke kompakter machen, \"Meta-Klassen\":</p> RegEx Entsprechungen <code>\\w</code> ein alphanumerisches Zeichen, einschlie\u00dflich <code>_</code> <code>\\W</code> ein nicht-alphanumerisches Zeichen <code>\\d</code> eine Ziffer (wie <code>[0-9]</code>) <code>\\D</code> eine nicht-Ziffer <code>\\s</code> ein Leerzeichen (wie <code>[ \\t\\n\\r\\f]</code>) <code>\\S</code> ein Nicht-Leerzeichen <code>\\h</code> horizontaler Leerraum: der Tabulator und alle Zeichen in der \"space separator\" Unicode-Kategorie <code>\\H</code> kein horizontaler Leerraum <code>\\v</code> vertikaler Leerraum: alle Zeichen, die im Unicode-Standard als Zeilenumbr\u00fcche behandelt werden <code>\\V</code> kein vertikaler Leerraum <code>\\R</code> Unicode-Zeilenumbruch: LF, Paar CR LF, CR, FF (Seitenvorschub), VT (vertikaler Tabulator), U+0085, U+2028, U+2029 <p>Du kannst alle oben genannten Meta-Klassen innerhalb benutzerdefinierter Zeichenklassen verwenden.</p> RegEx Entsprechungen <code>foob\\dr</code> <code>foob1r</code>, <code>foob6r</code> usw., aber nicht <code>foobar</code>, <code>foobbr</code> usw. <code>foob[\\w\\s]r</code> <code>foobar</code>, <code>foob r</code>, <code>foobbr</code> usw., aber nicht <code>foob1r</code>, <code>foob=r</code> usw. <p>TRegExpr</p> <p>Die Eigenschaften SpaceChars und WordChars definieren die Zeichenklassen <code>\\w</code>, <code>\\W</code>, <code>\\s</code>, <code>\\S</code>.</p> <p>So k\u00f6nnen Sie diese Klassen neu definieren.</p>"},{"location":"regular_expressions/#grenzen","title":"Grenzen","text":""},{"location":"regular_expressions/#zeilengrenzen","title":"Zeilengrenzen","text":"Meta-Zeichen Entsprechungen <code>^</code> \u00dcbereinstimmung der L\u00e4nge Null am Anfang der Zeile <code>$</code> \u00dcbereinstimmung der L\u00e4nge Null am Ende der Zeile <code>\\A</code> \u00dcbereinstimmung der L\u00e4nge Null ganz am Anfang <code>\\z</code> \u00dcbereinstimmung der L\u00e4nge Null ganz am Ende <code>\\Z</code> wie <code>\\z</code>, entspricht aber auch vor dem letzten Zeilenumbruch <code>\\G</code> \u00dcbereinstimmung der L\u00e4nge Null am Ende der vorherigen \u00dcbereinstimmung <p>Beispiele:</p> RegEx Entsprechungen <code>^foobar</code> <code>foobar</code> nur, wenn es am Anfang einer Zeile steht <code>foobar$</code> <code>foobar</code> nur, wenn es am Ende einer Zeile steht <code>^foobar$</code> <code>foobar</code> nur, wenn es die einzige Zeichenkette in einer Zeile ist <code>foob.r</code> <code>foobar</code>, <code>foobbr</code>, <code>foob1r</code> usw. <p>Das Meta-Zeichen <code>^</code> entspricht einer Position der L\u00e4nge Null am Anfang des Eingabestrings. <code>$</code> - am Ende. Wenn der Modifikator /m eingeschaltet ist, entsprechen sie auch am Anfang/Ende einzelner Zeilen im mehrzeiligen Text.</p> <p>Beachte, dass es keine leere Zeile innerhalb der Sequenz <code>\\x0D\\x0A</code> gibt.</p> <p>TRegExpr</p> <p>Wenn Sie die Unicode-Version verwenden, dann passen <code>^</code>/<code>$</code> auch zu <code>\\x2028</code>, <code>\\x2029</code>, <code>\\x0B</code>, <code>\\x0C</code> oder <code>\\x85</code>.</p> <p>Das Meta-Zeichen <code>\\A</code> passt auf die nulllange Position ganz am Anfang des Eingabestrings, <code>\\z</code> - ganz am Ende. Sie ignorieren den Modifikator /m. <code>\\Z</code> ist wie <code>\\z</code>, passt aber auch vor dem finalen Zeilenumbruch (LF und CR LF). Das Verhalten von <code>\\A</code>, <code>\\z</code>, <code>\\Z</code> ist wie in den meisten gro\u00dfen Regex-Engines (Perl, PCRE usw.) gestaltet.</p> <p>Beachten Sie, dass <code>^.*$</code> nicht auf einen String zwischen <code>\\x0D\\x0A</code> passt, weil dies ein unteilbarer Zeilenseparator ist. Aber es passt auf den leeren String innerhalb der Sequenz <code>\\x0A\\x0D</code>, weil dies 2 Zeilenumbr\u00fcche in der falschen Reihenfolge sind.</p> <p>TRegExpr</p> <p>Die Verarbeitung von mehrzeiligen Texten kann durch die Eigenschaften LineSeparators und UseLinePairedBreak angepasst werden.</p> <p>So k\u00f6nnen Sie Unix-Stil Trennzeichen <code>\\n</code> oder DOS/Windows-Stil <code>\\r\\n</code> verwenden oder sie zusammen mischen (wie im oben beschriebenen Standardverhalten).</p> <p>Wenn Sie eine mathematisch korrekte Beschreibung bevorzugen, finden Sie diese auf www.unicode.org.</p>"},{"location":"regular_expressions/#wortgrenzen","title":"Wortgrenzen","text":"RegEx Entsprechungen <code>\\b</code> eine Wortgrenze <code>\\B</code> keine Wortgrenze <p>Eine Wortgrenze <code>\\b</code> ist ein Punkt zwischen zwei Zeichen, von denen eines ein <code>\\w</code> und das andere ein <code>\\W</code> ist (in beliebiger Reihenfolge).</p>"},{"location":"regular_expressions/#quantifizierung","title":"Quantifizierung","text":""},{"location":"regular_expressions/#quantoren","title":"Quantoren","text":"<p>Jedes Element eines regul\u00e4ren Ausdrucks kann von einem Quantor gefolgt werden. Ein Quantor gibt die Anzahl der Wiederholungen des Elements an.</p> RegEx Entsprechungen <code>{n}</code> genau <code>n</code> Mal <code>{n,}</code> mindestens <code>n</code> Mal <code>{,m}</code> nicht mehr als <code>m</code> Mal (nur mit AllowBraceWithoutMin) <code>{n,m}</code> mindestens <code>n</code>, aber nicht mehr als <code>m</code> Mal <code>*</code> null oder mehr, \u00e4hnlich wie <code>{0,}</code> <code>+</code> einmal oder mehr, \u00e4hnlich wie <code>{1,}</code> <code>?</code> null oder einmal, \u00e4hnlich wie <code>{0,1}</code> <p>Ziffern in geschweiften Klammern <code>{n,m}</code>, geben die minimale Anzahl von Malen <code>n</code> und die maximale <code>m</code> an.</p> <p><code>{n}</code> ist \u00e4quivalent zu <code>{n,n}</code> und entspricht genau <code>n</code> Mal. <code>{n,}</code> entspricht <code>n</code> oder mehr Mal.</p> <p>Die Variante <code>{,m}</code> wird nur unterst\u00fctzt, wenn die Eigenschaft AllowBraceWithoutMin gesetzt ist.</p> <p>Es gibt keine praktische Begrenzung f\u00fcr die Werte n und m (Grenze ist maximaler vorzeichenbehafteter 32-Bit-Wert).</p> <p>Die Verwendung von <code>{</code> ohne einen korrekten Bereich f\u00fchrt zu einem Fehler. Dieses Verhalten kann ge\u00e4ndert werden, indem die Eigenschaft AllowLiteralBraceWithoutRange gesetzt wird, welche <code>{</code> als Literalzeichen akzeptiert, wenn es nicht von einem Bereich gefolgt wird. Ein Bereich mit einem niedrigeren Wert gr\u00f6\u00dfer als der hohe Wert f\u00fchrt immer zu einem Fehler.</p> RegEx Entsprechungen <code>foob.*r</code> <code>foobar</code>, \u00a0<code>foobalkjdflkj9r</code> und <code>foobr</code> <code>foob.+r</code> <code>foobar</code>, <code>foobalkjdflkj9r</code> aber nicht <code>foobr</code> <code>foob.?r</code> <code>foobar</code>, <code>foobbr</code> und <code>foobr</code> aber nicht <code>foobalkj9r</code> <code>fooba{2}r</code> <code>foobaar</code> <code>fooba{2,}r</code> <code>foobaar'</code>, <code>foobaaar</code>, <code>foobaaaar</code> usw. <code>fooba{2,3}r</code> <code>foobaar</code>, oder <code>foobaaar</code> \u00a0aber nicht <code>foobaaaar</code> <code>(foobar){8,10}</code> 8...10 Instanzen von <code>foobar</code> (<code>()</code> ist Gruppe) <p></p>"},{"location":"regular_expressions/#gierigkeit","title":"Gierigkeit","text":"<p>Quantoren im \"gierigen\" Modus nehmen so viel wie m\u00f6glich, im \"faulen\" Modus - so wenig wie m\u00f6glich.</p> <p>Standardm\u00e4\u00dfig sind alle Quantoren \"gierig\". F\u00fcge das Zeichen <code>?</code> hinzu, um jeden Quantor \"faul\" zu machen.</p> <p>F\u00fcr die Zeichenkette <code>abbbbc</code>:</p> RegEx \u00dcbereinstimmungen <code>b+</code> <code>bbbb</code> <code>b+?</code> <code>b</code> <code>b*?</code> leere Zeichenkette <code>b{2,3}?</code> <code>bb</code> <code>b{2,3}</code> <code>bbb</code> <p>Du kannst alle Quantoren in den \"faulen\" Modus umschalten (Modifikator /g, unten verwenden wir \u00c4nderung des Modifikators im Text).</p> RegEx \u00dcbereinstimmungen <code>(?-g)b+</code> <code>b</code>"},{"location":"regular_expressions/#besitzergreifender-quantor","title":"Besitzergreifender Quantor","text":"<p>Die Syntax lautet: <code>a++</code>, <code>a*+</code>, <code>a?+</code>, <code>a{2,4}+</code>. Derzeit wird sie nur f\u00fcr einfache Klammern unterst\u00fctzt, aber nicht f\u00fcr Klammern nach einer Gruppe wie <code>(foo|bar){3,5}+</code>.</p> <p>Diese Regex-Funktion wird hier beschrieben. Kurz gesagt, beschleunigt der besitzergreifende Quantor das Finden von \u00dcbereinstimmungen in komplexen F\u00e4llen.</p>"},{"location":"regular_expressions/#auswahl","title":"Auswahl","text":"<p>Ausdr\u00fccke in der Auswahl werden durch das vertikale Balken <code>|</code> getrennt.</p> <p>So wird <code>fee|fie|foe</code> jede von <code>fee</code>, <code>fie</code> oder <code>foe</code> in der Ziel- zeichenkette \u00fcbereinstimmen (wie auch <code>f(e|i|o)e</code>).</p> <p>Der erste Ausdruck umfasst alles vom letzten Musterbegrenzer (<code>(</code>, <code>[</code>, oder der Anfang des Musters) bis zum ersten <code>|</code>, und der letzte Ausdruck enth\u00e4lt alles vom letzten <code>|</code> zum n\u00e4chsten Musterbegrenzer.</p> <p>Das klingt ein wenig kompliziert, daher ist es \u00fcblich, die Auswahl in Klammern zu setzen, um Verwirrung dar\u00fcber zu minimieren, wo sie beginnt und endet.</p> <p>Ausdr\u00fccke in der Auswahl werden von links nach rechts ausprobiert, sodass der erste Ausdruck, der passt, der gew\u00e4hlte ist.</p> <p>Zum Beispiel wird der regul\u00e4re Ausdruck <code>foo|foot</code> in der Zeichenkette <code>barefoot</code> <code>foo</code> \u00fcbereinstimmen. Nur der erste Ausdruck, der passt.</p> <p>Denk auch daran, dass <code>|</code> als w\u00f6rtliches Zeichen innerhalb von eckigen Klammern interpretiert wird, also wenn du <code>[fee|fie|foe]</code> schreibst, \u00fcbereinstimmst du wirklich nur mit <code>[feio|]</code>.</p> RegEx \u00dcbereinstimmungen <code>foo(bar|foo)</code> <code>foobar</code> oder <code>foofoo</code> <p></p>"},{"location":"regular_expressions/#gruppen","title":"Gruppen","text":"<p>Die Klammern <code>()</code> werden verwendet, um Gruppen (d.h. Unterexpressionen) zu definieren.</p> <p>[!NOTE] TRegExpr</p> <p>Gruppenpositionen, L\u00e4ngen und tats\u00e4chliche Werte werden in MatchPos, MatchLen und Match sein.</p> <p>Du kannst sie mit Substitute ersetzen.</p> <p>Gruppen werden von links nach rechts durch ihre \u00f6ffnende Klammer nummeriert (einschlie\u00dflich verschachtelter Gruppen). Die erste Gruppe hat den Index 1. Der gesamte Regex hat den Index 0.</p> Gruppe Wert 0 <code>foobar</code> 1 <code>foobar</code> 2 <code>bar</code>"},{"location":"regular_expressions/#ruckverweise","title":"R\u00fcckverweise","text":"<p>Metazeichen <code>\\1</code> bis <code>\\9</code> werden als R\u00fcckverweise auf Erfassungsgruppen interpretiert. Sie stimmen mit der zuvor gefundenen Gruppe mit dem angegebenen Index \u00fcberein.</p> <p>Das Metazeichen <code>\\g</code> gefolgt von einer Zahl wird ebenfalls als R\u00fcckverweise auf Erfassungsgruppen interpretiert. Es kann von einer mehrstelligen Zahl gefolgt werden.</p> RegEx \u00dcbereinstimmungen <code>(.)\\1+</code> <code>aaaa</code> und <code>cc</code> <code>(.+)\\1+</code> auch <code>abab</code> und <code>123123</code> <code>(.)\\g1+</code> <code>aaaa</code> und <code>cc</code> <p>RegEx <code>(['\"]?)(\\d+)\\1</code> passt zu <code>\"13\"</code> (in Anf\u00fchrungszeichen), oder <code>'4'</code> (in einfachen Anf\u00fchrungszeichen) oder <code>77</code> (ohne Anf\u00fchrungszeichen) usw.</p>"},{"location":"regular_expressions/#benannte-gruppen-und-ruckverweise","title":"Benannte Gruppen und R\u00fcckverweise","text":"<p>Benannte Gruppen in regul\u00e4ren Ausdr\u00fccken erm\u00f6glichen es Ihnen, einen Teil Ihres Musters zu beschriften.  Das macht Ihre Muster leichter verst\u00e4ndlich und aktualisierbar.</p> <p>Um eine benannte Gruppe zu erstellen, verwenden Sie <code>(?&lt;name&gt;pattern)</code> oder <code>(?'name'pattern)</code>,  wobei <code>name</code> der Name der Gruppe ist und <code>pattern</code> das Regex-Muster, das Sie erfassen m\u00f6chten.</p> <p>R\u00fcckverweise erm\u00f6glichen es Ihnen, denselben Text wie eine zuvor getroffene Gruppe zu matchen.  Benannte R\u00fcckverweise verwenden <code>\\k&lt;name&gt;</code>, wobei <code>name</code> der Name der Gruppe ist, die Sie erneut matchen m\u00f6chten.</p> <p>TRegExpr unterst\u00fctzt auch die Perl-Version: <code>(?P&lt;name&gt;pattern)</code> um eine benannte Gruppe zu definieren und <code>(?P=name)</code>  f\u00fcr R\u00fcckverweise.</p> <p>Beispiel</p> RegEx \u00dcbereinstimmungen <code>(?P&lt;qq&gt;['\"])\\w+(?P=qq)</code> <code>\"wort\"</code> und <code>'wort'</code>"},{"location":"regular_expressions/#ubereinstimmendes-ergebnis","title":"\u00dcbereinstimmendes Ergebnis","text":"<p>Der Beginn der gemeldeten \u00dcbereinstimmung kann mit <code>\\K</code> gesetzt werden.</p> <p>Standardm\u00e4\u00dfig wird der gesamte von einem Muster abgedeckte Text als \u00fcbereinstimmend angesehen. Es ist jedoch m\u00f6glich, explizit festzulegen, was gemeldet wird.</p> <p>Das Muster <code>a\\Kb</code> erfordert, dass der Text \"ab\" enth\u00e4lt. Aber nur der \"b\" wird als \u00fcbereinstimmend gemeldet. Es kann mehrere <code>\\K</code> in einem Muster geben, Das letzte setzt die Startposition der \u00dcbereinstimmung. Nur <code>\\K</code> in aktiven Teilen des Musters werden ber\u00fccksichtigt. Z.B. <code>a(\\Kb)?</code> wird nicht <code>\\K</code> ber\u00fccksichtigen, wenn es kein \"b\" gibt. Erfassungen k\u00f6nnen au\u00dferhalb der durch <code>\\K</code> gesetzten \u00dcbereinstimmung existieren.</p> <p>Wenn es in anderen Konstrukten verwendet wird, die au\u00dferhalb der gemeldeten \u00dcbereinstimmung angewendet werden k\u00f6nnen (wie Vorausschau), dann muss die durch <code>\\K</code> markierte Position vor oder bei dem gemeldeten Ende der \u00dcbereinstimmung liegen. Wenn die Position sp\u00e4ter markiert wird, wird die \u00dcbereinstimmung als gescheitert angesehen.</p> <p><code>\\K</code> ist in gewisser Weise \u00e4hnlich einer R\u00fcckw\u00e4rtssuche. Im Gegensatz zu einer R\u00fcckw\u00e4rtssuche muss der Teil des Musters vor dem <code>\\K</code> nach dem Startpunkt der \u00dcbereinstimmung liegen, wenn das Muster von einer Versatzposition innerhalb des Textes angewendet wird.</p>"},{"location":"regular_expressions/#modifikatoren","title":"Modifikatoren","text":"<p>Modifikatoren dienen zur \u00c4nderung des Verhaltens von regul\u00e4ren Ausdr\u00fccken.</p> <p>Du kannst Modifikatoren global in deinem System setzen oder innerhalb des regul\u00e4ren Ausdrucks \u00e4ndern, indem du (?imsxr-imsxr) verwendest.</p> <p>TRegExpr</p> <p>Um Modifikatoren zu \u00e4ndern, verwende ModifierStr oder entsprechende <code>TRegExpr</code>-Eigenschaften Modifier*.</p> <p>Die Standardwerte sind in globalen Variablen definiert. Zum Beispiel definiert die globale Variable <code>RegExprModifierX</code> den Standardwert f\u00fcr die Eigenschaft <code>ModifierX</code>.</p> <p></p>"},{"location":"regular_expressions/#i-gro-kleinschreibung-ignorieren","title":"i, Gro\u00df-/Kleinschreibung ignorieren","text":"<p>Gro\u00df-/Kleinschreibung ignorieren. Verwendet die in deinem System installierten Gebietsschema-Einstellungen, siehe auch InvertCase.</p> <p></p>"},{"location":"regular_expressions/#m-mehrzeilige-zeichenketten","title":"m, Mehrzeilige Zeichenketten","text":"<p>Behandelt die Zeichenkette als mehrere Zeilen. So passen <code>^</code> und <code>$</code> auf den Anfang oder das Ende einer beliebigen Zeile innerhalb der Zeichenkette.</p> <p>Siehe auch Zeilenbegrenzungen.</p> <p></p>"},{"location":"regular_expressions/#s-einzeilige-zeichenketten","title":"s, Einzeilige Zeichenketten","text":"<p>Behandelt die Zeichenkette als eine einzige Zeile. So passt <code>.</code> auf jedes beliebige Zeichen, sogar auf Zeilentrenner.</p> <p>Siehe auch Zeilenbegrenzungen, mit denen es normalerweise nicht \u00fcbereinstimmen w\u00fcrde.</p> <p></p>"},{"location":"regular_expressions/#g-gierigkeit","title":"g, Gierigkeit","text":"<p>TRegExpr nur Modifikator.</p> <p>Durch Ausschalten wechselst du Quantoren in nicht-gierigen Modus.</p> <p>Wenn also der Modifikator <code>/g</code> <code>Aus</code> ist, dann funktioniert <code>+</code> als <code>+?</code>, <code>*</code> als <code>*?</code> und so weiter.</p> <p>Standardm\u00e4\u00dfig ist dieser Modifikator <code>Ein</code>.</p> <p></p>"},{"location":"regular_expressions/#x-erweiterte-syntax","title":"x, Erweiterte Syntax","text":"<p>Erm\u00f6glicht es, regul\u00e4re Ausdr\u00fccke zu kommentieren und in mehrere Zeilen aufzuteilen.</p> <p>Wenn der Modifikator <code>Ein</code> ist, ignorieren wir alle Leerzeichen, die weder mit einem R\u00fcckstrich versehen noch innerhalb einer Zeichenklasse sind.</p> <p>Und das <code>#</code> Zeichen trennt Kommentare.</p> <p>Beachte, dass du leere Zeilen verwenden kannst, um den regul\u00e4ren Ausdruck f\u00fcr bessere Lesbarkeit zu formatieren:</p> <pre><code>(\n(abc) # Kommentar 1\n#\n(efg) # Kommentar 2\n)\n</code></pre> <p>Das bedeutet auch, dass wenn du echte Leerzeichen oder <code>#</code> Zeichen im Muster m\u00f6chtest (au\u00dferhalb einer Zeichenklasse, wo sie von <code>/x</code> unbeeinflusst sind), musst du sie entweder escapen oder sie mit oktalen oder hexadezimalen Escapes kodieren.</p> <p></p>"},{"location":"regular_expressions/#r-russische-bereiche","title":"r, Russische Bereiche","text":"<p>TRegExpr nur Modifikator.</p> <p>In der russischen ASCII-Tabelle sind die Zeichen <code>\u0451</code>/<code>\u0401</code> separat von anderen platziert.</p> <p>Gro\u00dfe und kleine russische Buchstaben sind in getrennten Bereichen, das ist dasselbe wie bei englischen Buchstaben, aber dennoch wollte ich eine kurze Form.</p> <p>Mit diesem Modifikator kannst du statt <code>[\u0430-\u044f\u0410-\u042f\u0451\u0401]</code> <code>[\u0430-\u042f]</code> schreiben, wenn du alle russischen Buchstaben brauchst.</p> <p>Wenn der Modifikator <code>Ein</code> ist:</p> RegEx \u00dcbereinstimmungen <code>\u0430-\u044f</code> Zeichen von <code>\u0430</code> bis <code>\u044f</code> und <code>\u0451</code> <code>\u0410-\u042f</code> Zeichen von <code>\u0410</code> bis <code>\u042f</code> und <code>\u0401</code> <code>\u0430-\u042f</code> alle russischen Symbole <p>Der Modifikator ist standardm\u00e4\u00dfig <code>Ein</code> gesetzt.</p>"},{"location":"regular_expressions/#behauptungen-vorausschau-ruckblick","title":"Behauptungen (Vorausschau, R\u00fcckblick)","text":"<p>Positive Vorausschau-Behauptung: <code>foo(?=bar)</code> passt zu \"foo\" nur vor \"bar\", und \"bar\" ist von der \u00dcbereinstimmung ausgeschlossen.</p> <p>Negative Vorausschau-Behauptung: <code>foo(?!bar)</code> passt zu \"foo\" nur, wenn es nicht von \"bar\" gefolgt wird.</p> <p>Positive R\u00fcckblick-Behauptung: <code>(?&lt;=foo)bar</code> passt zu \"bar\" nur nach \"foo\", und \"foo\" ist von der \u00dcbereinstimmung ausgeschlossen.</p> <p>Negative R\u00fcckblick-Behauptung: <code>(?&lt;!foo)bar</code> passt zu \"bar\" nur, wenn es nicht mit \"foo\" beginnt.</p> <p>Einschr\u00e4nkungen:</p> <ul> <li>R\u00fcckblicke variabler L\u00e4nge d\u00fcrfen keine Erfassungsgruppen enthalten.   Dies kann durch Einstellen der Eigenschaft <code>AllowUnsafeLookBehind</code> erlaubt werden.   Wenn dies aktiviert ist und es im Text mehr als eine \u00dcbereinstimmung gibt, die   die Gruppe erfassen k\u00f6nnte, dann k\u00f6nnte die falsche \u00dcbereinstimmung erfasst werden. Dies   beeintr\u00e4chtigt nicht die Richtigkeit der gesamten Behauptung. (D.h., der   R\u00fcckblick wird korrekt zur\u00fcckgeben, ob der Text davor dem   Muster entsprach).</li> <li>R\u00fcckblicke variabler L\u00e4nge k\u00f6nnen langsam ausgef\u00fchrt werden, wenn sie nicht   \u00fcbereinstimmen.</li> </ul>"},{"location":"regular_expressions/#nicht-erfassende-gruppen","title":"Nicht erfassende Gruppen","text":"<p>Die Syntax ist wie folgt: <code>(?:expr)</code>.</p> <p>Solche Gruppen haben keinen \"Index\" und sind f\u00fcr R\u00fcckverweise unsichtbar. Nicht erfassende Gruppen werden verwendet, wenn du eine Unterexpression gruppieren m\u00f6chtest, aber sie nicht als \u00fcbereinstimmenden/erfassten Teil der Zeichenkette speichern m\u00f6chtest. Also ist dies nur eine M\u00f6glichkeit, deinen Regex in Unterexpressionen zu organisieren, ohne die Last der Erfassung des Ergebnisses:</p> RegEx \u00dcbereinstimmungen <code>(https?|ftp)://([^/\\r\\n]+)</code> in <code>https://sorokin.engineer</code> \u00fcbereinstimmt <code>https</code> und <code>sorokin.engineer</code> <code>(?:https?|ftp)://([^/\\r\\n]+)</code> in <code>https://sorokin.engineer</code> \u00fcbereinstimmt nur <code>sorokin.engineer</code>"},{"location":"regular_expressions/#atomare-gruppen","title":"Atomare Gruppen","text":"<p>Die Syntax ist wie folgt: <code>(?&gt;expr|expr|...)</code>.</p> <p>Atomare Gruppen sind ein Spezialfall von nicht erfassenden Gruppen. Beschreibung von ihnen.</p>"},{"location":"regular_expressions/#inline-modifikatoren","title":"Inline-Modifikatoren","text":"<p>Syntax f\u00fcr einen Modifikator: <code>(?i)</code> zum Einschalten, und <code>(?-i)</code> zum Ausschalten. Viele Modifikatoren sind erlaubt wie: <code>(?msgxr-imsgxr)</code>.</p> <p>Du kannst sie innerhalb des regul\u00e4ren Ausdrucks verwenden, um Modifikatoren on-the-fly zu \u00e4ndern. Dies kann besonders praktisch sein, weil es lokalen Geltungsbereich in einem regul\u00e4ren Ausdruck hat. Es betrifft nur den Teil des regul\u00e4ren Ausdrucks, der auf <code>(?imsgxr-imsgxr)</code> folgt.</p> <p>Und wenn es innerhalb einer Gruppe ist, betrifft es nur diese Gruppe - speziell den Teil der Gruppe, der auf die Modifikatoren folgt. Also in <code>((?i)Saint)-Petersburg</code> betrifft es nur die Gruppe <code>((?i)Saint)</code>, sodass es <code>saint-Petersburg</code> aber nicht <code>saint-petersburg</code> \u00fcbereinstimmt.</p> <p>Inline-Modifikatoren k\u00f6nnen auch als Teil einer nicht erfassenden Gruppe gegeben werden: <code>(?i:Muster)</code>.</p> RegEx \u00dcbereinstimmungen <code>(?i)Saint-Petersburg</code> <code>Saint-petersburg</code> und <code>Saint-Petersburg</code> <code>(?i)Saint-(?-i)Petersburg</code> <code>Saint-Petersburg</code> aber nicht <code>Saint-petersburg</code> <code>(?i)(Saint-)?Petersburg</code> <code>Saint-petersburg</code> und <code>saint-petersburg</code> <code>((?i)Saint-)?Petersburg</code> <code>saint-Petersburg</code>, aber nicht <code>saint-petersburg</code>"},{"location":"regular_expressions/#kommentare","title":"Kommentare","text":"<p>Die Syntax ist wie folgt: <code>(?#text)</code>. Text innerhalb der Klammern wird ignoriert.</p> <p>Beachte, dass der Kommentar durch das n\u00e4chstgelegene <code>)</code> geschlossen wird, also gibt es keine M\u00f6glichkeit, ein w\u00f6rtliches <code>)</code> im Kommentar zu setzen.</p>"},{"location":"regular_expressions/#rekursion","title":"Rekursion","text":"<p>Die Syntax ist <code>(?R)</code>, das Alias ist <code>(?0)</code>.</p> <p>Der Regex <code>a(?R)?z</code> passt auf ein oder mehrere \"a\" gefolgt von genau derselben Anzahl von \"z\".</p> <p>Der Hauptzweck der Rekursion ist das Abgleichen von ausgeglichenen oder verschachtelten Konstrukten. Der generische Regex lautet <code>b(?:m|(?R))*e</code>, wobei \"b\" den Anfang des Konstrukts, \"m\" das, was in der Mitte des Konstrukts vorkommen kann, und \"e\" das, was am Ende des Konstrukts steht, darstellt.</p> <p>Wenn das, was in der Mitte des ausgeglichenen Konstrukts erscheinen kann, auch allein ohne die Anfangs- und Endteile erscheinen kann, dann lautet der generische Regex <code>b(?R)*e|m</code>.</p>"},{"location":"regular_expressions/#unterprogrammaufrufe","title":"Unterprogrammaufrufe","text":"<p>Syntax f\u00fcr den Aufruf von nummerierten Gruppen: <code>(?1)</code> ... <code>(?90)</code> (der maximale Index ist durch den Code begrenzt).</p> <p>Syntax f\u00fcr den Aufruf von benannten Gruppen: <code>(?P&gt;name)</code>. Auch die Perl-Syntax wird unterst\u00fctzt: <code>(?&amp;name)</code>, <code>\\g&lt;name&gt;</code> und <code>\\g'name'</code>.</p> <p>Dies \u00e4hnelt der Rekursion, ruft aber nur den Code der Erfassungsgruppe mit dem angegebenen Index auf.</p>"},{"location":"regular_expressions/#unicode-kategorien","title":"Unicode-Kategorien","text":"<p>Der Unicode-Standard hat Namen f\u00fcr Zeichenkategorien. Dies sind 2-Buchstaben-Strings. Zum Beispiel ist \"Lu\" f\u00fcr Gro\u00dfbuchstaben, \"Ll\" f\u00fcr Kleinbuchstaben. Und die 1-Buchstaben-Kategorie \"L\" steht f\u00fcr alle Buchstaben.</p> <ul> <li>Cc - Steuerzeichen</li> <li>Cf - Format</li> <li>Co - Private Nutzung</li> <li>Cs - Surrrogat</li> <li>Ll - Kleinbuchstabe</li> <li>Lm - Modifikationsbuchstabe</li> <li>Lo - Anderer Buchstabe</li> <li>Lt - Titelbuchstabe</li> <li>Lu - Gro\u00dfbuchstabe</li> <li>Mc - Zwischenraumzeichen</li> <li>Me - Umschlie\u00dfendes Zeichen</li> <li>Mn - Nichtabstandzeichen</li> <li>Nd - Dezimalzahl</li> <li>Nl - Buchstabennummer</li> <li>No - Andere Zahl</li> <li>Pc - Verbindungszeichen</li> <li>Pd - Bindestrich</li> <li>Pe - Schlie\u00dfendes Satzzeichen</li> <li>Pf - Endendes Satzzeichen</li> <li>Pi - Beginnendes Satzzeichen</li> <li>Po - Anderes Satzzeichen</li> <li>Ps - \u00d6ffnendes Satzzeichen</li> <li>Sc - W\u00e4hrungszeichen</li> <li>Sk - Modifikatorzeichen</li> <li>Sm - Mathematisches Zeichen</li> <li>So - Anderes Symbol</li> <li>Zl - Zeilenseparator</li> <li>Zp - Absatzseparator</li> <li>Zs - Leerzeichen</li> </ul> <p>Das Metazeichen <code>\\p</code> steht f\u00fcr ein Unicode-Zeichen der angegebenen Kategorie. Syntax: <code>\\pL</code> und <code>\\p{L}</code> f\u00fcr einen 1-Buchstaben-Namen, <code>\\p{Lu}</code> f\u00fcr 2-Buchstaben-Namen.</p> <p>Das Metazeichen <code>\\P</code> ist invertiert, es steht f\u00fcr ein Unicode-Zeichen nicht in der angegebenen Kategorie.</p> <p>Diese Metazeichen werden auch innerhalb von Zeichenklassen unterst\u00fctzt.</p>"},{"location":"regular_expressions/#nachwort","title":"Nachwort","text":"<p>In diesem alten Blogbeitrag aus dem letzten Jahrhundert illustriere ich einige Anwendungen von regul\u00e4ren Ausdr\u00fccken.</p>"},{"location":"tregexpr/","title":"Tregexpr","text":"Englisch \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Deutsch \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Fran\u00e7ais Spanisch"},{"location":"tregexpr/#tregexpr","title":"TRegExpr","text":"<p>To use it, copy files \"regexpr.pas\", \"regexpr_unicodedata.pas\", \"regexpr_compilers.inc\", to your project folder.</p> <p>The library is already included into Lazarus (Free Pascal) project so you do not need to copy anything if you use Lazarus.</p>"},{"location":"tregexpr/#klasse-tregexpr","title":"Klasse TRegExpr","text":""},{"location":"tregexpr/#haupt-und-nebenversion","title":"Haupt- und Nebenversion","text":"<p>Return major and minor version of the component.</p> <pre><code>VersionMajor = 1\nVersionMinor = 101\n</code></pre>"},{"location":"tregexpr/#ausdruck","title":"Ausdruck","text":"<p>Ein regul\u00e4rer Ausdruck.</p> <p>For optimization, regular expression is automatically compiled into P-code. Human-readable form of the P-code is returned by Dump.</p> <p>In case of any errors in compilation, <code>Error</code> method is called (by default <code>Error</code> raises exception ERegExpr).</p>"},{"location":"tregexpr/#modifierstr","title":"ModifierStr","text":"<p>Set or get values of regular expression modifiers.</p> <p>Format of the string is similar to (?ismx-ismx). For example <code>ModifierStr := \u2018i-x\u2019</code> will switch on the modifier /i, switch off /x and leave unchanged others.</p> <p>Wenn Sie versuchen, einen nicht unterst\u00fctzten Modifikator einzustellen, wird <code>Error</code> aufgerufen.</p>"},{"location":"tregexpr/#modifieri","title":"ModifierI","text":"<p>Modifier /i, \"case-insensitive\", initialized with RegExprModifierI value.</p>"},{"location":"tregexpr/#modifierr","title":"ModifierR","text":"<p>Modifier /r, \"Russian range extension\", initialized with RegExprModifierR value.</p>"},{"location":"tregexpr/#modifiers","title":"ModifierS","text":"<p>Modifier /s, \"single line strings\", initialized with RegExprModifierS value.</p>"},{"location":"tregexpr/#modifierg","title":"ModifierG","text":"<p>Modifier /g, \"greediness\", initialized with RegExprModifierG value.</p>"},{"location":"tregexpr/#modifierm","title":"ModifierM","text":"<p>Modifier /m, \"multi-line strings\", initialized with RegExprModifierM value.</p>"},{"location":"tregexpr/#modifierx","title":"ModifierX","text":"<p>Modifier /x, \"eXtended syntax\", initialized with RegExprModifierX value.</p>"},{"location":"tregexpr/#exec","title":"Exec","text":"<p>Finds regular expression against <code>AInputString</code>, starting from the beginning.</p> <p>The overloaded <code>Exec</code> version without <code>AInputString</code> exists, it uses <code>AInputString</code> from previous call.</p> <p>See also global function ExecRegExpr that you can use without explicit <code>TRegExpr</code> object creation.</p>"},{"location":"tregexpr/#execnext","title":"ExecNext","text":"<p>Finds next match. If parameter <code>ABackward</code> is True, it goes downto position 1, ie runs backward search.</p> <p>Without parameter it works the same as:</p> <pre><code>if SpielLen [0] = 0\n  then ExecPos (SpielPos [0] + 1)\n  else ExecPos (SpielPos [0] + SpielLen [0]);\n</code></pre> <p>Raises exception if used without preceeding successful call to Exec, ExecPos or ExecNext.</p> <p>So you always must use something like:</p> <pre><code>if Exec(InputString)\n  then\n    repeat\n      { proceed results}\n    until not ExecNext;\n</code></pre>"},{"location":"tregexpr/#execpos","title":"ExecPos","text":"<p>Finds match for <code>AInputString</code> starting from <code>AOffset</code> position (1-based).</p> <p>Parameter <code>ABackward</code> means going from <code>AOffset</code> downto 1, ie backward search.</p> <p>Parameter <code>ATryOnce</code> means that testing for regex will be only at the initial position, without going to next/previous positions.</p>"},{"location":"tregexpr/#inputstring","title":"InputString","text":"<p>Returns current input string (from last Exec call or last assign to this property).</p> <p>Jede Zuweisung zu dieser Eigenschaft setzt Spiel, SpielPos und SpielLen zur\u00fcck.</p>"},{"location":"tregexpr/#substitute","title":"Substitute","text":"<pre><code>function Substitute (const ATemplate: RegExprString): RegExprString;\n</code></pre> <p>Returns <code>ATemplate</code>, where <code>$&amp;</code> or <code>$0</code> are replaced with the found match, and <code>$1</code> to <code>$9</code> are replaced with found groups 1 to 9.</p> <p>To use in template the characters <code>$</code> or <code>\\</code>, escape them with a backslash <code>\\</code>, like <code>\\\\</code> or <code>\\$</code>.</p> Symbol Description <code>$&amp;</code> ganze \u00dcbereinstimmung des regul\u00e4ren Ausdrucks <code>$0</code> ganze \u00dcbereinstimmung des regul\u00e4ren Ausdrucks <code>$1</code> .. <code>$9</code> contents of numbered group 1 .. 9 <code>\\n</code> in Windows durch <code>\\r\\n</code> ersetzt <code>\\l</code> lowercase one next char <code>\\L</code> Kleinbuchstaben alle Zeichen danach <code>\\u</code> uppercase one next char <code>\\U</code> Gro\u00dfbuchstaben alle Zeichen danach <pre><code>'1\\$ is $2\\\\rub\\\\' -&gt; '1$ is &lt;Spiel[2]&gt;\\rub\\'\n'\\U$1\\\\r' transforms into '&lt;Spiel[1] in uppercase&gt;\\r'\n</code></pre> <p>If you want to place raw digit after \u2018\\$n\u2019 you must delimit <code>n</code> with curly braces <code>{}</code>.</p> <pre><code>'a$12bc' -&gt; 'a&lt;Spiel[12]&gt;bc'\n'a${1}2bc' -&gt; 'a&lt;Spiel[1]&gt;2bc'.\n</code></pre> <p>To use found named groups, use syntax <code>${name}</code>, where \"name\" is valid identifier of previously found named group (starting with non-digit).</p>"},{"location":"tregexpr/#split","title":"Split","text":"<p>Splits <code>AInputStr</code> into <code>APieces</code> by regex occurrences.</p> <p>Ruft intern Exec / ExecNext auf</p> <p>See also global function SplitRegExpr that you can use without explicit <code>TRegExpr</code> object creation.</p> <p></p>"},{"location":"tregexpr/#replace-replaceex","title":"Replace, ReplaceEx","text":"<pre><code>function Replace (Const AInputStr : RegExprString;\n  const AReplaceStr : RegExprString;\n  AUseSubstitution : boolean= False)\n : RegExprString; overload;\n\nfunction Replace (Const AInputStr : RegExprString;\n  AReplaceFunc : TRegExprReplaceFunction)\n : RegExprString; overload;\n\nfunction ReplaceEx (Const AInputStr : RegExprString;\n  AReplaceFunc : TRegExprReplaceFunction):\n  RegExprString;\n</code></pre> <p>Returns the string with regex occurencies replaced by the replace string.</p> <p>If last argument (<code>AUseSubstitution</code>) is true, then <code>AReplaceStr</code> will be used as template for Substitution methods.</p> <pre><code>Ausdruck := '((?i)block|var)\\s*(\\s*\\([^ ]*\\)\\s*)\\s*';\nReplace ('BLOCK( test1)', 'def \"$1\" value \"$2\"', True);\n</code></pre> <p>Liefert <code>def \"BLOCK\" Wert &amp;quot;test1&amp;quot;</code></p> <pre><code>Ersetzen (&amp;#39;BLOCK (test1)&amp;#39;, &amp;#39;def &amp;quot;$ 1&amp;quot; Wert &amp;quot;$ 2&amp;quot;&amp;#39;, False)\n</code></pre> <p>Liefert <code>def &amp;quot;$ 1&amp;quot; Wert &amp;quot;$ 2&amp;quot;</code></p> <p>Ruft intern Exec / ExecNext auf</p> <p>Overloaded version and <code>ReplaceEx</code> operate with callback function, so you can implement really complex functionality.</p> <p>See also global function ReplaceRegExpr that you can use without explicit <code>TRegExpr</code> object creation.</p>"},{"location":"tregexpr/#subexprspielcount","title":"SubExprSpielCount","text":"<p>Count of groups (subexpressions) found in last Exec / ExecNext call.</p> <p>If there are no groups found, but some string was found (Exec* returned True), it returns 0. If no groups nor some string were found (Exec / ExecNext returned false), it returns -1.</p> <p>Note, that some group may be not found, and for such group <code>MathPos=SpielLen=-1</code> and <code>Spiel=\u2019\u2019</code>.</p> <pre><code>Ausdruck := '(1)?2(3)?';\nExec ('123'): SubExprSpielCount=2, Spiel[0]='123', [1]='1', [2]='3'\n\nExec ('12'): SubExprSpielCount=1, Spiel[0]='12', [1]='1'\n\nExec ('23'): SubExprSpielCount=2, Spiel[0]='23', [1]='', [2]='3'\n\nExec ('2'): SubExprSpielCount=0, Spiel[0]='2'\n\nExec ('7') - return False: SubExprSpielCount=-1\n</code></pre>"},{"location":"tregexpr/#spielpos","title":"SpielPos","text":"<p>Position (1-based) of group with specified index. Result is valid only after some match was found. First group has index 1, the entire match has index 0.</p> <p>Returns -1 if no group with specified index was found.</p>"},{"location":"tregexpr/#spiellen","title":"SpielLen","text":"<p>Length of group with specified index. Result is valid only after some match was found. First group has index 1, the entire match has index 0.</p> <p>Returns -1 if no group with specified index was found.</p>"},{"location":"tregexpr/#spiel","title":"Spiel","text":"<p>String of group with specified index. First group has index 1, the entire match has index 0. Returns empty string, if no such group was found.</p>"},{"location":"tregexpr/#spielindexfromname","title":"SpielIndexFromName","text":"<p>Returns group index (1-based) from group name, which is needed for \"named groups\". Returns -1 if no such named group was found.</p>"},{"location":"tregexpr/#lasterror","title":"LastError","text":"<p>Returns Id of last error, or 0 if no errors occured (unusable if <code>Error</code> method raises exception). It also clears internal status to 0 (no errors).</p>"},{"location":"tregexpr/#errormsg","title":"ErrorMsg","text":"<p>Gibt die <code>Error</code>-Nachricht f\u00fcr einen Fehler mit <code>ID = AErrorID</code> zur\u00fcck.</p>"},{"location":"tregexpr/#kompilierenrerrorpos","title":"KompilierenrErrorPos","text":"<p>Returns position in regex, where P-code compilation was stopped.</p> <p>Useful for error diagnostics.</p>"},{"location":"tregexpr/#spacechars","title":"SpaceChars","text":"<p>Contains chars, treated as <code>\\s</code> (initially filled with RegExprSpaceChars global constant).</p>"},{"location":"tregexpr/#wordchars","title":"WordChars","text":"<p>Contains chars, treated as <code>\\w</code> (initially filled with RegExprWordChars global constant).</p>"},{"location":"tregexpr/#lineseparators","title":"LineSeparators","text":"<p>Line separators (like <code>\\n</code> in Unix), initially filled with RegExprLineSeparators global constant).</p> <p>See also Line Boundaries</p>"},{"location":"tregexpr/#uselinepairedbreak","title":"UseLinePairedBreak","text":"<p>Boolean property, enables to detect paired line separator CR LF.</p> <p>See also Line Boundaries</p> <p>For example, if you need only Unix-style separator LF, assign <code>LineSeparators := #$a</code> and <code>UseLinePairedBreak := False</code>.</p> <p>If you want to accept as line separators only CR LF but not CR or LF alone, then assign <code>LineSeparators := ''</code> (empty string) and <code>UseLinePairedBreak := True</code>.</p> <p>By default, \"mixed\" mode is used (defined in RegExprLineSeparators global constant):</p> <pre><code>LineSeparators := #$d#$a; \nUseLinePairedBreak := True;\n</code></pre> <p>Behaviour of this mode is described in the Line Boundaries.</p>"},{"location":"tregexpr/#kompilieren","title":"Kompilieren","text":"<p>Kompilierens regular expression to internal P-code.</p> <p>Useful for example for GUI regular expressions editors - to check regular expression without using it.</p>"},{"location":"tregexpr/#dump","title":"Dump","text":"<p>Shows P-code (compiled regular expression) as human-readable string.</p>"},{"location":"tregexpr/#globale-konstanten","title":"Globale Konstanten","text":""},{"location":"tregexpr/#escchar","title":"EscChar","text":"<p>Escape character, by default backslash <code>'\\'</code>.</p>"},{"location":"tregexpr/#substitutegroupchar","title":"SubstituteGroupChar","text":"<p>Char used to prefix groups (numbered and named) in Substitute method, by default <code>'$'</code>.</p>"},{"location":"tregexpr/#regexprmodifieri","title":"RegExprModifierI","text":"<p>Modifier i default value.</p>"},{"location":"tregexpr/#regexprmodifierr","title":"RegExprModifierR","text":"<p>Modifier r default value.</p>"},{"location":"tregexpr/#regexprmodifiers","title":"RegExprModifierS","text":"<p>Modifier s default value.</p>"},{"location":"tregexpr/#regexprmodifierg","title":"RegExprModifierG","text":"<p>Modifier g default value.</p>"},{"location":"tregexpr/#regexprmodifierm","title":"RegExprModifierM","text":"<p>Modifier m default value.</p>"},{"location":"tregexpr/#regexprmodifierx","title":"RegExprModifierX","text":"<p>Modifier x default value.</p>"},{"location":"tregexpr/#regexprspacechars","title":"RegExprSpaceChars","text":"<p>Default for SpaceChars property.</p>"},{"location":"tregexpr/#regexprwordchars","title":"RegExprWordChars","text":"<p>Default value for WordChars property. \u00a0 RegExprLineSeparators \\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~~</p> <p>Default value for LineSeparators property.</p>"},{"location":"tregexpr/#globale-funktionen","title":"Globale Funktionen","text":"<p>All this functionality is available as methods of <code>TRegExpr</code>, but with global functions you do not need to create <code>TReExpr</code> instance so your code would be more simple if you just need one function.</p>"},{"location":"tregexpr/#execregexpr","title":"ExecRegExpr","text":"<p>Returns True if the string matches the regular expression. Just like Exec in <code>TRegExpr</code>.</p>"},{"location":"tregexpr/#splitregexpr","title":"SplitRegExpr","text":"<p>Splits the string by regular expression occurences. See also Split if you prefer to create <code>TRegExpr</code> instance explicitly.</p>"},{"location":"tregexpr/#replaceregexpr","title":"ReplaceRegExpr","text":"<pre><code>function ReplaceRegExpr (\n    const ARegExpr, AInputStr, AReplaceStr : RegExprString;\n    AUseSubstitution : boolean= False\n) : RegExprString; overload;\n\nType\n  TRegexReplaceOption = (rroModifierI,\n                         rroModifierR,\n                         rroModifierS,\n                         rroModifierG,\n                         rroModifierM,\n                         rroModifierX,\n                         rroUseSubstitution,\n                         rroUseOsLineEnd);\n  TRegexReplaceOptions = Set of TRegexReplaceOption;\n\nfunction ReplaceRegExpr (\n    const ARegExpr, AInputStr, AReplaceStr : RegExprString;\n    Options :TRegexReplaceOptions\n) : RegExprString; overload;\n</code></pre> <p>Returns the string with regular expressions replaced by the <code>AReplaceStr</code>. See also Replace if you prefer to create TRegExpr instance explicitly.</p> <p>If last argument (<code>AUseSubstitution</code>) is True, then <code>AReplaceStr</code> will be used as template for <code>Substitution methods</code>:</p> <pre><code>ReplaceRegExpr (\n  '((?i)block|var)\\s*(\\s*\\([^ ]*\\)\\s*)\\s*',\n  'BLOCK(test1)',\n  'def \"$1\" value \"$2\"',\n  True\n)\n</code></pre> <p>Returns <code>def 'BLOCK' value 'test1'</code></p> <p>Aber dieses hier (Anmerkung: Es gibt kein letztes Argument):</p> <pre><code>ReplaceRegExpr (\n  '((?i)block|var)\\s*(\\s*\\([^ ]*\\)\\s*)\\s*',\n  'BLOCK(test1)',\n  'def \"$1\" value \"$2\"'\n)\n</code></pre> <p>Liefert <code>def &amp;quot;$ 1&amp;quot; Wert &amp;quot;$ 2&amp;quot;</code></p>"},{"location":"tregexpr/#version-mit-optionen","title":"Version mit Optionen","text":"<p>With <code>Options</code> you control <code>\\n</code> behaviour (if <code>rroUseOsLineEnd</code> then <code>\\n</code> is replaced with <code>\\n\\r</code> in Windows and <code>\\n</code> in Linux). And so on.</p> <pre><code>Type\n  TRegexReplaceOption = (rroModifierI,\n                         rroModifierR,\n                         rroModifierS,\n                         rroModifierG,\n                         rroModifierM,\n                         rroModifierX,\n                         rroUseSubstitution,\n                         rroUseOsLineEnd);\n</code></pre>"},{"location":"tregexpr/#quoteregexprmetachars","title":"QuoteRegExprMetaChars","text":"<p>Replace all metachars with its safe representation, for example <code>abc'cd.(</code> is converted to <code>abc\\'cd\\.\\(</code></p> <p>This function is useful for regex auto-generation from user input.</p>"},{"location":"tregexpr/#regexprsubausdrucks","title":"RegExprSubAusdrucks","text":"<p>Makes list of subexpressions found in <code>ARegExpr</code>.</p> <p>In <code>ASubExps</code> every item represents subexpression, from first to last, in format:</p> <p>String - Unterausdruck (ohne '()')</p> <p>Low word of Object - starting position in ARegExpr, including \u2018(\u2019 if exists! (first position is 1)</p> <p>High word of Object - length, including starting \u2018(\u2019 and ending \u2018)\u2019 if exist!</p> <p><code>AExtendedSyntax</code> - must be True if modifier <code>/x</code> os on, while using the regex.</p> <p>Usefull for GUI editors of regex (you can find example of usage in REStudioMain.pas)</p> <p>=========== ======= Ergebniscode Bedeutung =========== ======= 0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Success. No unbalanced brackets were found. -1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Not enough closing brackets <code>)</code>. - (n + 1) \u00a0 \u00a0 \u00a0At position n it was found opening <code>[</code> without corresponding closing <code>]</code>. n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 At position n it was found closing bracket <code>)</code> without corresponding opening <code>(</code>. =========== =======\u00a0</p> <p>If <code>Result &lt;&gt; 0</code>, then <code>ASubExprs</code> can contain empty items or illegal ones.</p>"},{"location":"tregexpr/#eregexpr","title":"ERegExpr","text":"<pre><code>ERegExpr = class (Exception)\n\u00a0 public\n\u00a0 \u00a0ErrorCode : integer; // error code. Compilation error codes are before 1000\n\u00a0 \u00a0KompilierenrErrorPos : integer; // Position in r.e. where compilation error occured\n\u00a0end;\n</code></pre>"},{"location":"tregexpr/#unicode","title":"Unicode","text":"<p>In Unicode mode, all strings (InputString, Ausdruck, internal strings) are of type UnicodeString/WideString, instead of simple \"string\". Unicode slows down performance, so use it only if you really need Unicode support.</p> <p>To use Unicode, uncomment <code>{$DEFINE UniCode}</code> in regexpr.pas (remove <code>off</code>).</p>"}]}