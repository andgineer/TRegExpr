{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"English \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Deutsch \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Fran\u00e7ais Espa\u00f1ol"},{"location":"#introduction","title":"Introduction","text":"<p>TRegExpr library implements regular expressions.</p> <p>Regular expressions are easy to use and powerful tool for sophisticated search and substitution and for template based text check.</p> <p>It is especially useful for user input validation in input forms - to validate e-mail addresses and so on.</p> <p>Also you can extract phone numbers, ZIP-codes etc from web-pages or documents, search for complex patterns in log files and all you can imagine. Rules (templates) can be changed without your program recompilation.</p> <p>TRegExpr is implemented in pure Pascal. It's included into Lazarus (Free Pascal):  package.  But also it exists as separate library and can be compiled by Delphi 2-7, Borland C++ Builder 3-6.</p> <p>How good the library was met.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>To use the library just add the sources to you project and use the class TRegExpr.</p> <p>In the FAQ you can learn from others users problems.</p> <p>Ready to run Windows application REStudio will help you learn and debug regular expressions.</p> <p>If you see any problems, please create the bug.</p>"},{"location":"#translations","title":"Translations","text":"<p>The documentation has been translated into English and Russian.</p> <p>There are incomplete translations into several other languages.  If you want to help complete them, contact me.</p>"},{"location":"#gratitude","title":"Gratitude","text":"<p>Many features suggested and a lot of bugs founded (and even fixed) by TRegExpr\u2019s contributors.</p> <p>I cannot list here all of them, but I do appreciate all bug-reports, features suggestions and questions that I am receiving from you.</p> <ul> <li>Alexey Torgashin - main contributor since 2019, e.g. </li> <li>named groups, non-capturing groups, assertions, backward search and much more</li> <li>Guido Muehlwitz - found and fixed ugly bug in big string processing</li> <li>Stephan Klimek - testing in C++Builder and suggesting/implementing   many features</li> <li>Steve Mudford - implemented Offset parameter</li> <li>Martin Baur (www.mindpower.com) -German   translation, usefull suggestions</li> <li>Yury Finkel - implemented Unicode support, found and fixed some bugs</li> <li>Ralf Junker - implemented some features, many optimization suggestions</li> <li>Simeon Lilov - Bulgarian translation</li> <li>Filip Jirs\u0431k and Matthew Winter - help in implementation non-greedy   mode</li> <li>Kit Eason - many examples for introduction help section</li> <li>Juergen Schroth - bug hunting and useful suggestions</li> <li>Martin Ledoux - French translation</li> <li>Diego Calp, Argentina - Spanish translation</li> </ul>"},{"location":"demos/","title":"Demos","text":"<p>Demo code for TRegExpr</p>"},{"location":"demos/#introduction","title":"Introduction","text":"<p>If you don't familiar with regular expression, please, take a look at the r.e.syntax.</p> <p>TRegExpr interface described in TRegExpr interface.</p>"},{"location":"demos/#text2html","title":"Text2HTML","text":"<p>Text2HTML sources</p> <p>Publish plain text as HTML</p> <p>Uses unit HyperLinksDecorator that is based on TRegExpr. \u00a0 This unit contains functions to decorate hyper-links.</p> <p>For example, replaces <code>www.sorokin.engineer</code> with <code>&lt;a href=\"http://www.sorokin.engineer\"&gt;www.sorokin.engineer&lt;/a&gt;</code> or <code>filbert@yandex.ru</code> with <code>&lt;a href=\"mailto:filbert@yandex.ru\"&gt;filbert@yandex.ru&lt;/a&gt;</code>. \u00a0 .. code-block:: pascal</p> <p>function DecorateURLs ( const AText : string; AFlags : TDecorateURLsFlagSet = [durlAddr, durlPath]</p> <p>) : string;</p> <p>type TDecorateURLsFlags = ( durlProto, durlAddr, durlPort, durlPath, durlBMark, durlParam);</p> <p>TDecorateURLsFlagSet = set of TDecorateURLsFlags;</p> <p>function DecorateEMails (const AText : string) : string; \u00a0</p> Value Meaning durlProto Protocol (like <code>ftp://</code> or <code>http://</code>) durlAddr \u00a0 TCP address or domain name (like <code>sorokin.engineer</code>) durlPort \u00a0 Port number if specified (like <code>:8080</code>) durlPath \u00a0 Path to document (like <code>index.html</code>) durlBMark Book mark (like <code>#mark</code>) durlParam URL params (like <code>?ID=2&amp;User=13</code>) <p>Returns input text <code>AText</code> with decorated hyper links.</p> <p><code>AFlags</code> describes, which parts of hyper-link must be included into visible part of the link.</p> <p>For example, if AFlags is <code>[durlAddr]</code> then hyper link <code>www.sorokin.engineer/contacts.htm</code> will be decorated as <code>&lt;a href=\"www.sorokin.engineer/contacts.htm\"&gt;www.sorokin.engineer&lt;/a&gt;</code>.</p>"},{"location":"demos/#tregexprroutines","title":"TRegExprRoutines","text":"<p>Very simple examples, see comments inside the unit</p>"},{"location":"demos/#tregexprclass","title":"TRegExprClass","text":"<p>Slightly more complex examples, see comments inside the unit</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#i-found-a-terrible-bug-tregexpr-raises-access-violation-exception","title":"I found a terrible bug: TRegExpr raises Access Violation exception!","text":"<p>Answer</p> <p>You must create the object before usage. So, after you declared something like:</p> <pre><code>r : TRegExpr\n</code></pre> <p>do not forget to create the object instance:</p> <pre><code>r := TRegExpr.Create. \n</code></pre>"},{"location":"faq/#does-it-support-unicode","title":"Does it support Unicode?","text":"<p>Answer</p> <p>How to use Unicode</p>"},{"location":"faq/#why-does-tregexpr-return-more-then-one-line","title":"Why does TRegExpr return more then one line?","text":"<p>For example, r.e. <code>&lt;font .\\*&gt;</code> returns the first <code>&lt;font</code>, then the rest of the file including last <code>&lt;/html&gt;</code>.</p> <p>Answer</p> <p>For backward compatibility, modifier /s is <code>On</code> by default.</p> <p>Switch it Off and <code>.</code> will match any but Line separators - exactly as you wish.</p> <p>BTW I suggest <code>&lt;font ([^\\n&gt;]*)&gt;</code>, in <code>Match[1]</code> will be the URL.</p>"},{"location":"faq/#why-does-tregexpr-return-more-then-i-expect","title":"Why does TRegExpr return more then I expect?","text":"<p>For example r.e. <code>&lt;p&gt;(.+)&lt;/p&gt;</code> applyed to string <code>&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;</code> returns <code>a&lt;/p&gt;&lt;p&gt;b</code> but not <code>a</code> as I expected.</p> <p>Answer</p> <p>By default all operators works in <code>greedy</code> mode, so they match as more as it possible.</p> <p>If you want <code>non-greedy</code> mode you can use <code>non-greedy</code> operators like <code>+?</code> and so on or switch all operators into <code>non-greedy</code> mode with help of modifier <code>g</code> (use appropriate TRegExpr properties or operator <code>?(-g)</code> in r.e.).</p>"},{"location":"faq/#how-to-parse-sources-like-html-with-help-of-tregexpr","title":"How to parse sources like HTML with help of TRegExpr?","text":"<p>Answer</p> <p>Sorry folks, but it's nearly impossible!</p> <p>Of course, you can easily use TRegExpr for extracting some information from HTML, as shown in my examples, but if you want accurate parsing you have to use real parser, not r.e.</p> <p>You can read full explanation in Tom Christiansen and Nathan Torkington <code>Perl Cookbook</code>, for example.</p> <p>In short - there are many structures that can be easy parsed by real parser but cannot at all by r.e., and real parser is much faster to do the parsing, because r.e. doesn't simply scan input stream, it performs optimization search that can take a lot of time.</p>"},{"location":"faq/#is-there-a-way-to-get-multiple-matches-of-a-pattern-on-tregexpr","title":"Is there a way to get multiple matches of a pattern on TRegExpr?","text":"<p>Answer</p> <p>You can iterate matches with ExecNext method.</p> <p>If you want some example, please take a look at <code>TRegExpr.Replace</code> method implementation or at the examples for HyperLinksDecorator</p>"},{"location":"faq/#i-am-checking-user-faqmdinput-why-does-tregexpr-return-true-for-wrong-input-strings","title":"I am checking user faq.mdinput. Why does TRegExpr return <code>True</code> for wrong input strings?","text":"<p>Answer</p> <p>In many cases TRegExpr users forget that regular expression is for search in input string.</p> <p>So, for example if you use <code>\\d{4,4}</code> expression, you will get success for wrong user inputs like <code>12345</code> or <code>any letters 1234</code>.</p> <p>You have to check from line start to line end to ensure there are no anything else around: <code>^\\d{4,4}$</code>.</p>"},{"location":"faq/#why-does-non-greedy-iterators-sometimes-work-as-in-greedy-mode","title":"Why does non-greedy iterators sometimes work as in greedy mode?","text":"<p>For example, the r.e. <code>a+?,b+?</code> applied to string <code>aaa,bbb</code> matches <code>aaa,b</code>, but should it not match <code>a,b</code> because of non-greediness of first iterator?</p> <p>Answer</p> <p>This is because of TRegExpr way to work. In fact many others r.e. engines work exactly the same: they performe only <code>simple</code> search optimization, and do not try to do the best optimization.</p> <p>In some cases it's bad, but in common it's rather advantage then limitation, because of performance and predictability reasons.</p> <p>The main rule - r.e. first of all try to match from current place and only if that's completely impossible move forward by one char and try again from next position in the text.</p> <p>So, if you use <code>a,b+?</code> it'll match <code>a,b</code>. In case of <code>a+?,b+?</code> it's now not recommended (we add non-greedy modifyer) but still possible to match more then one <code>a</code>, so TRegExpr will do it.</p> <p>TRegExpr like Perl's or Unix's r.e. doesn't attempt to move forward and check - would it will be \"better\" match. Fisrt of all, just because there is no way to say it's more or less good match.</p>"},{"location":"faq/#how-can-i-use-tregexpr-with-borland-c-builder","title":"How can I use TRegExpr with Borland C++ Builder?","text":"<p>I have a problem since no header file (<code>.h</code> or <code>.hpp</code>) is available.</p> <p>Answer</p> <ul> <li>Add <code>RegExpr.pas</code> to <code>bcb</code> project.</li> <li>Compile project. This generates the header file <code>RegExpr.hpp</code>.</li> <li>Now you can write code which uses the <code>RegExpr</code> unit.</li> <li>Don't forget to add \u00a0<code>#include \u201cRegExpr.hpp\u201d</code> where needed.</li> <li>Don't forget to replace all <code>\\</code> in regular expressions with <code>\\\\</code> or   redefined EscChar const.</li> </ul>"},{"location":"faq/#why-many-re-including-re-from-tregexpr-help-and-demo-work-wrong-in-borland-c-builder","title":"Why many r.e. (including r.e. from TRegExpr help and demo) work wrong in Borland C++ Builder?","text":"<p>Answer</p> <p>The hint is in the previous question ;) Symbol <code>\\</code> has special meaning in <code>C++</code>, so you have to <code>escape</code> it (as described in previous answer). But if you don't like r.e. like <code>\\\\w+\\\\w+\\\\.\\\\w+</code> you can redefine the constant <code>EscChar</code> (in <code>RegExpr.pas</code>). For example <code>EscChar = \"/\"</code>. Then you can write <code>/w+/w+/./w+</code>, looks unusual but more readable.</p>"},{"location":"regular_expressions/","title":"Regular expressions (RegEx)","text":""},{"location":"regular_expressions/#introduction","title":"Introduction","text":"<p>Regular expressions are a handy way to specify patterns of text.</p> <p>With regular expressions you can validate user input, search for some patterns like emails of phone numbers on web pages or in some documents and so on.</p> <p>Below is the complete regular expressions cheat sheet.</p>"},{"location":"regular_expressions/#characters","title":"Characters","text":""},{"location":"regular_expressions/#simple-matches","title":"Simple matches","text":"<p>Any single character (except special regex characters) matches itself. A series of (not special) characters matches that series of characters in the input string.</p> RegEx Matches <code>foobar</code> <code>foobar</code>"},{"location":"regular_expressions/#non-printable-characters-escape-codes","title":"Non-Printable Characters (escape-codes)","text":"<p>To specify character by its Unicode code, use the prefix <code>\\x</code> followed by the hex code. For 3-4 digits code (after U+00FF), enclose the code into braces.</p> RegEx Matches <code>\\xAB</code> character with 2-digit hex code <code>AB</code> <code>\\x{AB20}</code> character with 1..4-digit hex code <code>AB20</code> <code>foo\\x20bar</code> <code>foo bar</code> (note space in the middle) <p>There are a number of predefined escape-codes for non-printable characters, like in C language:</p> RegEx Matches <code>\\t</code> tab (HT/TAB), same as <code>\\x09</code> <code>\\n</code> line feed (LF), same as <code>\\x0a</code> <code>\\r</code> carriage return (CR), same as <code>\\x0d</code> <code>\\f</code> form feed (FF), same as <code>\\x0c</code> <code>\\a</code> alarm (BEL), same as <code>\\x07</code> <code>\\e</code> escape (ESC), same as <code>\\x1b</code> <p><code>\\cA</code> ... <code>\\cZ</code></p> chr(0) to chr(25). For example, <code>\\cI</code> matches the tab-char. Lower-case letters \"a\"...\"z\" are also supported. <p></p>"},{"location":"regular_expressions/#escaping","title":"Escaping","text":"<p>To represent special regex character (one of <code>.+*?|\\()[]{}^$</code>), prefix it with a backslash <code>\\</code>. The literal backslash must be escaped too.</p> RegEx Matches <code>\\^FooBarPtr</code> <code>^FooBarPtr</code>, this is <code>^</code> and not start of line <code>\\[a\\]</code> <code>[a]</code>, this is not character class"},{"location":"regular_expressions/#character-classes","title":"Character Classes","text":""},{"location":"regular_expressions/#user-character-classes","title":"User Character Classes","text":"<p>Character class is a list of characters inside square brackets <code>[]</code>. The class matches any single character listed in this class.</p> RegEx Matches <code>foob[aeiou]r</code> <code>foobar</code>, <code>foober</code> etc but not <code>foobbr</code>, <code>foobcr</code> etc <p>You can \"invert\" the class - if the first character after the <code>[</code> is <code>^</code>, then the class matches any character except the characters listed in the class.</p> RegEx Matches <code>foob[^aeiou]r</code> <code>foobbr</code>, <code>foobcr</code> etc but not <code>foobar</code>, <code>foober</code> etc <p>Within a list, the dash <code>-</code> character is used to specify a range, so that <code>a-z</code> represents all characters between <code>a</code> and <code>z</code>, inclusive.</p> <p>If you want the dash <code>-</code> itself to be a member of a class, put it at the start or end of the list, or escape it with a backslash.</p> <p>If you want <code>]</code> as part of the class you may place it at the start of list or escape it with a backslash.</p> RegEx Matches <code>[-az]</code> <code>a</code>, <code>z</code> and <code>-</code> <code>[az-]</code> <code>a</code>, <code>z</code> and <code>-</code> <code>[a\\-z]</code> <code>a</code>, <code>z</code> and <code>-</code> <code>[a-z]</code> characters from <code>a</code> to <code>z</code> <code>[\\n-\\x0D]</code> characters from chr(10) to chr(13)"},{"location":"regular_expressions/#dot-meta-char","title":"Dot Meta-Char","text":"<p>Meta-char <code>.</code> (dot) by default matches any character. But if you turn off the modifier /s, then it won't match line-break characters.</p> <p>The <code>.</code> does not act as meta-class inside user character classes. <code>[.]</code> means a literal \".\".</p>"},{"location":"regular_expressions/#meta-classes","title":"Meta-Classes","text":"<p>There are a number of predefined character classes that keeps regular expressions more compact, \"meta-classes\":</p> RegEx Matches <code>\\w</code> an alphanumeric character, including <code>_</code> <code>\\W</code> a non-alphanumeric <code>\\d</code> a numeric character (same as <code>[0-9]</code>) <code>\\D</code> a non-numeric <code>\\s</code> any space (same as <code>[ \\t\\n\\r\\f]</code>) <code>\\S</code> a non-space <p><code>\\h</code></p> horizontal whitespace: the tab and all characters in the \"space separator\" Unicode category <code>\\H</code> not a horizontal whitespace <p><code>\\v</code></p> vertical whitespace: all characters treated as line-breaks in the Unicode standard <code>\\V</code> not a vertical whitespace <p><code>\\R</code></p> unicode line break: LF, pair CR LF, CR, FF (form feed), VT (vertical tab), U+0085, U+2028, U+2029 <p>You may use all meta-classes, mentioned in the table above, within user character classes.</p> RegEx Matches <code>foob\\dr</code> <code>foob1r</code>, <code>foob6r</code> and so on, but not <code>foobar</code>, <code>foobbr</code> and so on <code>foob[\\w\\s]r</code> <code>foobar</code>, <code>foob r</code>, <code>foobbr</code> and so on, but not <code>foob1r</code>, <code>foob=r</code> and so on <p>TRegExpr</p> <p>Properties SpaceChars and WordChars define character classes <code>\\w</code>, <code>\\W</code>, <code>\\s</code>, <code>\\S</code>.</p> <p>So you can redefine these classes.</p>"},{"location":"regular_expressions/#boundaries","title":"Boundaries","text":""},{"location":"regular_expressions/#line-boundaries","title":"Line Boundaries","text":"Meta-char Matches <code>^</code> zero-length match at start of line <code>$</code> zero-length match at end of line <code>\\A</code> zero-length match at the very beginning <code>\\z</code> zero-length match at the very end <code>\\Z</code> like <code>\\z</code> but also matches before the final line-break <code>\\G</code> zero-length match at the end pos of the previous match <p>Examples:</p> RegEx Matches <code>^foobar</code> <code>foobar</code> only if it's at the beginning of line <code>foobar$</code> <code>foobar</code> only if it's at the end of line <code>^foobar$</code> <code>foobar</code> only if it's the only string in line <code>foob.r</code> <code>foobar</code>, <code>foobbr</code>, <code>foob1r</code> and so on <p>Meta-char <code>^</code> matches zero-length position at the beginning of the input string. <code>$</code> - at the ending. If modifier /m is on, they also match at the beginning/ending of individual lines in the multi-line text.</p> <p>Note that there is no empty line within the sequence <code>\\x0D\\x0A</code>.</p> <p>TRegExpr</p> <p>If you are using Unicode version, then <code>^</code>/<code>$</code> also matches <code>\\x2028</code>,\u00a0<code>\\x2029</code>, <code>\\x0B</code>, <code>\\x0C</code> or <code>\\x85</code>.</p> <p>Meta-char <code>\\A</code> matches zero-length position at the very beginning of the input string, <code>\\z</code> - at the very ending. They ignore modifier /m. <code>\\Z</code> is like <code>\\z</code> but also matches before the final line-break (LF and CR LF). Behaviour of <code>\\A</code>, <code>\\z</code>, <code>\\Z</code> is made like in most of major regex engines (Perl, PCRE, etc).</p> <p>Note that <code>^.*$</code> does not match a string between <code>\\x0D\\x0A</code>, because this is unbreakable line separator. But it matches the empty string within the sequence <code>\\x0A\\x0D</code> because this is 2 line-breaks in the wrong order.</p> <p>TRegExpr</p> <p>Multi-line processing can be tuned by properties LineSeparators and UseLinePairedBreak.</p> <p>So you can use Unix style separators <code>\\n</code> or DOS/Windows style <code>\\r\\n</code> or mix them together (as in described above default behaviour).</p> <p>If you prefer mathematically correct description you can find it on www.unicode.org.</p>"},{"location":"regular_expressions/#word-boundaries","title":"Word Boundaries","text":"RegEx Matches <code>\\b</code> a word boundary <code>\\B</code> a non-word boundary <p>A word boundary <code>\\b</code> is a spot between two characters that has a <code>\\w</code> on one side of it and a <code>\\W</code> on the other side of it (in either order).</p> <p></p>"},{"location":"regular_expressions/#quantification","title":"Quantification","text":""},{"location":"regular_expressions/#quantifiers","title":"Quantifiers","text":"<p>Any item of a regular expression may be followed by quantifier. Quantifier specifies number of repetitions of the item.</p> RegEx Matches <code>{n}</code> exactly <code>n</code> times <code>{n,}</code> at least <code>n</code> times <code>{,m}</code> not more than <code>m</code> times (only with AllowBraceWithoutMin) <code>{n,m}</code> at least <code>n</code> but not more than <code>m</code> times <code>*</code> zero or more, similar to <code>{0,}</code> <code>+</code> one or more, similar to <code>{1,}</code> <code>?</code> zero or one, similar to <code>{0,1}</code> <p>So, digits in curly brackets <code>{n,m}</code>, specify the minimum number of times to match <code>n</code> and the maximum <code>m</code>.</p> <p>The <code>{n}</code> is equivalent to <code>{n,n}</code> and matches exactly <code>n</code> times. The <code>{n,}</code> matches <code>n</code> or more times.</p> <p>The variant <code>{,m}</code> is only supported if the property AllowBraceWithoutMin is set.</p> <p>There is no practical limit to the values n and m (limit is maximal signed 32-bit value).</p> <p>Using <code>{</code> without a correct range will give an error. This behaviour can be changed by setting the property AllowLiteralBraceWithoutRange, which will accept <code>{</code> as a literal char, if not followed by a range. A range with a low value bigger than the high value will always give an error.</p> RegEx Matches <code>foob.*r</code> <code>foobar</code>, \u00a0<code>foobalkjdflkj9r</code> and <code>foobr</code> <code>foob.+r</code> <code>foobar</code>, <code>foobalkjdflkj9r</code> but not <code>foobr</code> <code>foob.?r</code> <code>foobar</code>, <code>foobbr</code> and <code>foobr</code> but not <code>foobalkj9r</code> <code>fooba{2}r</code> <code>foobaar</code> <code>fooba{2,}r</code> <code>foobaar'</code>, <code>foobaaar</code>, <code>foobaaaar</code> etc. <code>fooba{2,3}r</code> <code>foobaar</code>, or <code>foobaaar</code> \u00a0but not <code>foobaaaar</code> <code>(foobar){8,10}</code> 8...10 instances of <code>foobar</code> (<code>()</code> is group) <p></p>"},{"location":"regular_expressions/#greediness","title":"Greediness","text":"<p>Quantifiers in \"greedy\" mode takes as many as possible, in \"lazy\" mode - as few as possible.</p> <p>By default all quantifiers are \"greedy\". Append the character <code>?</code> to make any quantifier \"lazy\".</p> <p>For string <code>abbbbc</code>:</p> RegEx Matches <code>b+</code> <code>bbbb</code> <code>b+?</code> <code>b</code> <code>b*?</code> empty string <code>b{2,3}?</code> <code>bb</code> <code>b{2,3}</code> <code>bbb</code> <p>You can switch all quantifiers into \"lazy\" mode (modifier /g, below we use in-line modifier change).</p> RegEx Matches <code>(?-g)b+</code> <code>b</code>"},{"location":"regular_expressions/#possessive-quantifier","title":"Possessive Quantifier","text":"<p>The syntax is: <code>a++</code>, <code>a*+</code>, <code>a?+</code>, <code>a{2,4}+</code>. Currently it's supported only for simple braces, but not for braces after group like <code>(foo|bar){3,5}+</code>.</p> <p>This regex feature is described here. In short, possessive quantifier speeds up matching in complex cases.</p>"},{"location":"regular_expressions/#choice","title":"Choice","text":"<p>Expressions in the choice are separated by vertical bar <code>|</code>.</p> <p>So <code>fee|fie|foe</code> will match any of <code>fee</code>, <code>fie</code>, or <code>foe</code> in the target string (as would <code>f(e|i|o)e</code>).</p> <p>The first expression includes everything from the last pattern delimiter (<code>(</code>, <code>[</code>, or the beginning of the pattern) up to the first <code>|</code>, and the last expression contains everything from the last <code>|</code> to the next pattern delimiter.</p> <p>Sounds a little complicated, so it\u2019s common practice to include the choice in parentheses, to minimize confusion about where it starts and ends.</p> <p>Expressions in the choice are tried from left to right, so the first expression that matches, is the one that is chosen.</p> <p>For example, regular expression <code>foo|foot</code> in string <code>barefoot</code> will match <code>foo</code>. Just a first expression that matches.</p> <p>Also remember that <code>|</code> is interpreted as a literal within square brackets, so if you write <code>[fee|fie|foe]</code> you\u2019re really only matching <code>[feio|]</code>.</p> RegEx Matches <code>foo(bar|foo)</code> <code>foobar</code> or <code>foofoo</code> <p></p>"},{"location":"regular_expressions/#groups","title":"Groups","text":"<p>The brackets <code>()</code> are used to define groups (ie subexpressions).</p> <p>[!NOTE] TRegExpr</p> <p>Group positions, lengths and actual values will be in MatchPos, MatchLen and Match.</p> <p>You can substitute them with Substitute.</p> <p>Groups are numbered from left to right by their opening parenthesis (including nested groups). First group has index 1. The entire regex has index 0.</p> Group Value 0 <code>foobar</code> 1 <code>foobar</code> 2 <code>bar</code>"},{"location":"regular_expressions/#backreferences","title":"Backreferences","text":"<p>Meta-chars <code>\\1</code> through <code>\\9</code> are interpreted as backreferences to capture groups. They match the previously found group with the specified index.</p> <p>The meta char <code>\\g</code> followed by a number is also interpreted as backreferences to capture groups. It can be followed by a multi-digit number.</p> RegEx Matches <code>(.)\\1+</code> <code>aaaa</code> and <code>cc</code> <code>(.+)\\1+</code> also <code>abab</code> and <code>123123</code> <code>(.)\\g1+</code> <code>aaaa</code> and <code>cc</code> <p>RegEx <code>(['\"]?)(\\d+)\\1</code> matches <code>\"13\"</code> (in double quotes), or <code>'4'</code> (in single quotes) or <code>77</code> (without quotes) etc.</p>"},{"location":"regular_expressions/#named-groups-and-backreferences","title":"Named Groups and Backreferences","text":"<p>Named groups in regular expressions let you label a part of your pattern.  This makes your patterns easier to understand and update. </p> <p>To make a named group, use <code>(?&lt;name&gt;pattern)</code> or <code>(?'name'pattern)</code>, where <code>name</code> is the group's name  and <code>pattern</code> is the regex pattern you want to catch.</p> <p>Backreferences let you match the same text as a group did before.  Named backreferences use <code>\\k&lt;name&gt;</code>, where <code>name</code> is the group's name you want to match again.</p> <p>TRegExpr support also Perl version: <code>(?P&lt;name&gt;pattern)</code> to define a named group and <code>(?P=name)</code>  for backreferences.</p> <p>Example</p> RegEx Matches <code>(?P&lt;qq&gt;['\"])\\w+(?P=qq)</code> <code>\"word\"</code> and <code>'word'</code>"},{"location":"regular_expressions/#matched-result","title":"Matched Result","text":"<p>The begin of the reported match can be set using <code>\\K</code>.</p> <p>By default the entire text covered by a pattern is considered matched. However it is possible to set explicitly what will be reported.</p> <p>The pattern <code>a\\Kb</code> will require the text to contain \"ab\". But only the \"b\" will be reported as having been matched. Their can be several <code>\\K</code> in a pattern, The last one will set the match-start position. Only <code>\\K</code> in active parts of the pattern are considered. E.g. <code>a(\\Kb)?</code> will not consider <code>\\K</code> if there is no \"b\". Captures can exist outside the match set by <code>\\K</code>.</p> <p>If used in other constructs that can apply outside the reported match (like look-ahead), then the position marked by <code>\\K</code> must be before or at the reported end of the match. If the position is marked later, the match is considered failed.</p> <p><code>\\K</code> is somewhat similar to a look-behind. Unlike a look-behind the part of the pattern before the <code>\\K</code> must be after the start position of the matching, if the pattern is applied from an offset position within the text.</p>"},{"location":"regular_expressions/#modifiers","title":"Modifiers","text":"<p>Modifiers are for changing behaviour of regular expressions.</p> <p>You can set modifiers globally in your system or change inside the regular expression using the (?imsxr-imsxr).</p> <p>TRegExpr</p> <p>To change modifiers use ModifierStr or appropriate <code>TRegExpr</code> properties Modifier*.</p> <p>The default values are defined in global variables. For example global variable <code>RegExprModifierX</code> defines default value for <code>ModifierX</code> property.</p> <p></p>"},{"location":"regular_expressions/#i-case-insensitive","title":"i, case-insensitive","text":"<p>Case-insensitive. Use installed in you system locale settings, see also InvertCase.</p> <p></p>"},{"location":"regular_expressions/#m-multi-line-strings","title":"m, multi-line strings","text":"<p>Treat string as multiple lines. So <code>^</code> and <code>$</code> matches the start or end of any line anywhere within the string.</p> <p>See also Line Boundaries.</p> <p></p>"},{"location":"regular_expressions/#s-single-line-strings","title":"s, single line strings","text":"<p>Treat string as single line. So <code>.</code> matches any character whatsoever, even a line separators.</p> <p>See also Line Boundaries, which it normally would not match.</p> <p></p>"},{"location":"regular_expressions/#g-greediness","title":"g, greediness","text":"<p>TRegExpr only modifier.</p> <p>Switching it <code>Off</code> you\u2019ll switch quantifiers into non-greedy mode.</p> <p>So, if modifier <code>/g</code> is <code>Off</code> then <code>+</code> works as <code>+?</code>, <code>*</code> as <code>*?</code> and so on.</p> <p>By default this modifier is <code>On</code>.</p> <p></p>"},{"location":"regular_expressions/#x-extended-syntax","title":"x, eXtended syntax","text":"<p>Allows to comment regular expression and break them up into multiple lines.</p> <p>If the modifier is <code>On</code> we ignore all whitespaces that is neither backslashed nor within a character class.</p> <p>And the <code>#</code> character separates comments.</p> <p>Notice that you can use empty lines to format regular expression for better readability:</p> <pre><code>(\n(abc) # comment 1\n#\n(efg) # comment 2\n)\n</code></pre> <p>This also means that if you want real whitespace or <code>#</code> characters in the pattern (outside a character class, where they are unaffected by <code>/x</code>), you\u2019ll either have to escape them or encode them using octal or hex escapes.</p> <p></p>"},{"location":"regular_expressions/#r-russian-ranges","title":"r, Russian ranges","text":"<p>TRegExpr only modifier.</p> <p>In Russian ASCII table characters <code>\u0451</code>/<code>\u0401</code> are placed separately from others.</p> <p>Big and small Russian characters are in separated ranges, this is the same as with English characters but nevertheless I wanted some short form.</p> <p>With this modifier instead of <code>[\u0430-\u044f\u0410-\u042f\u0451\u0401]</code> you can write <code>[\u0430-\u042f]</code> if you need all Russian characters.</p> <p>When the modifier is <code>On</code>:</p> RegEx Matches <code>\u0430-\u044f</code> chars from <code>\u0430</code> to <code>\u044f</code> and <code>\u0451</code> <code>\u0410-\u042f</code> chars from <code>\u0410</code> to <code>\u042f</code> and <code>\u0401</code> <code>\u0430-\u042f</code> all russian symbols <p>The modifier is set On by default.</p>"},{"location":"regular_expressions/#assertions-lookahead-lookahead","title":"Assertions (lookahead, lookahead)","text":"<p>Positive lookahead assertion: <code>foo(?=bar)</code> matches \"foo\" only before \"bar\", and \"bar\" is excluded from the match.</p> <p>Negative lookahead assertion: <code>foo(?!bar)</code> matches \"foo\" only if it's not followed by \"bar\".</p> <p>Positive lookbehind assertion: <code>(?&lt;=foo)bar</code> matches \"bar\" only after \"foo\", and \"foo\" is excluded from the match.</p> <p>Negative lookbehind assertion: <code>(?&lt;!foo)bar</code> matches \"bar\" only if it's not prefixed with \"foo\".</p> <p>Limitations:</p> <ul> <li>Variable length lookbehind are not allowed to contain capture groups.   This can be allowed by setting the property <code>AllowUnsafeLookBehind</code>.   If this is enabled and there is more than one match in the text that   the group might capture, then the wrong match may be captured. This   does not affect the correctness of the overall assertion. (I.e., the   lookbehind will correctly return if the text before matched the   pattern).</li> <li>Variable length lookbehind may be slow to execute, if they do not   match.</li> </ul>"},{"location":"regular_expressions/#non-capturing-groups","title":"Non-capturing Groups","text":"<p>Syntax is like this: <code>(?:expr)</code>.</p> <p>Such groups do not have the \"index\" and are invisible for backreferences. Non-capturing groups are used when you want to group a subexpression, but you do not want to save it as a matched/captured portion of the string. So this is just a way to organize your regex into subexpressions without overhead of capturing result:</p> RegEx Matches <code>(https?|ftp)://([^/\\r\\n]+)</code> in <code>https://sorokin.engineer</code> matches <code>https</code> and <code>sorokin.engineer</code> <code>(?:https?|ftp)://([^/\\r\\n]+)</code> in <code>https://sorokin.engineer</code> matches only <code>sorokin.engineer</code>"},{"location":"regular_expressions/#atomic-groups","title":"Atomic Groups","text":"<p>Syntax is like this: <code>(?&gt;expr|expr|...)</code>.</p> <p>Atomic groups are special case of non-capturing groups. Description of them.</p>"},{"location":"regular_expressions/#inline-modifiers","title":"Inline Modifiers","text":"<p>Syntax for one modifier: <code>(?i)</code> to turn on, and <code>(?-i)</code> to turn off. Many modifiers are allowed like this: <code>(?msgxr-imsgxr)</code>.</p> <p>You may use it inside regular expression for modifying modifiers on-the-fly. This can be especially handy because it has local scope in a regular expression. It affects only that part of regular expression that follows <code>(?imsgxr-imsgxr)</code> operator.</p> <p>And if it's inside group, it will affect only this group - specifically the part of the group that follows the modifiers. So in <code>((?i)Saint)-Petersburg</code> it affects only group <code>((?i)Saint)</code> so it will match <code>saint-Petersburg</code> but not <code>saint-petersburg</code>.</p> <p>Inline modifiers can also be given as part of a non-capturing group: <code>(?i:pattern)</code>.</p> RegEx Matches <code>(?i)Saint-Petersburg</code> <code>Saint-petersburg</code> and <code>Saint-Petersburg</code> <code>(?i)Saint-(?-i)Petersburg</code> <code>Saint-Petersburg</code> but not <code>Saint-petersburg</code> <code>(?i)(Saint-)?Petersburg</code> <code>Saint-petersburg</code> and <code>saint-petersburg</code> <code>((?i)Saint-)?Petersburg</code> <code>saint-Petersburg</code>, but not <code>saint-petersburg</code>"},{"location":"regular_expressions/#comments","title":"Comments","text":"<p>Syntax is like this: <code>(?#text)</code>. Text inside brackets is ignored.</p> <p>Note that the comment is closed by the nearest <code>)</code>, so there is no way to put a literal <code>)</code> in the comment.</p>"},{"location":"regular_expressions/#recursion","title":"Recursion","text":"<p>Syntax is <code>(?R)</code>, the alias is <code>(?0)</code>.</p> <p>The regex <code>a(?R)?z</code> matches one or more letters \"a\" followed by exactly the same number of letters \"z\".</p> <p>The main purpose of recursion is to match balanced constructs or nested constructs. The generic regex is <code>b(?:m|(?R))*e</code> where \"b\" is what begins the construct, \"m\" is what can occur in the middle of the construct, and \"e\" is what occurs at the end of the construct.</p> <p>If what may appear in the middle of the balanced construct may also appear on its own without the beginning and ending parts then the generic regex is <code>b(?R)*e|m</code>.</p>"},{"location":"regular_expressions/#subroutine-calls","title":"Subroutine calls","text":"<p>Syntax for call to numbered groups: <code>(?1)</code> ... <code>(?90)</code> (maximal index is limited by code).</p> <p>Syntax for call to named groups: <code>(?P&gt;name)</code>. Also supports: <code>(?&amp;name)</code>, <code>\\g&lt;name&gt;</code> and <code>\\g'name'</code>.</p> <p>This is like recursion but calls only code of capturing group with specified index.</p>"},{"location":"regular_expressions/#unicode-categories","title":"Unicode Categories","text":"<p>Unicode standard has names for character categories. These are 2-letter strings. For example \"Lu\" is uppercase letters, \"Ll\" is lowercase letters. And 1-letter bigger category \"L\" is all letters.</p> <ul> <li>Cc - Control</li> <li>Cf - Format</li> <li>Co - Private Use</li> <li>Cs - Surrrogate</li> <li>Ll - Lowercase Letter</li> <li>Lm - Modifier Letter</li> <li>Lo - Other Letter</li> <li>Lt - Titlecase Letter</li> <li>Lu - Uppercase Letter</li> <li>Mc - Spacing Mark</li> <li>Me - Enclosing Mark</li> <li>Mn - Nonspacing Mark</li> <li>Nd - Decimal Number</li> <li>Nl - Letter Number</li> <li>No - Other Number</li> <li>Pc - Connector Punctuation</li> <li>Pd - Dash Punctuation</li> <li>Pe - Close Punctuation</li> <li>Pf - Final Punctuation</li> <li>Pi - Initial Punctuation</li> <li>Po - Other Punctuation</li> <li>Ps - Open Punctuation</li> <li>Sc - Currency Symbol</li> <li>Sk - Modifier Symbol</li> <li>Sm - Math Symbol</li> <li>So - Other Symbol</li> <li>Zl - Line Separator</li> <li>Zp - Paragraph Separator</li> <li>Zs - Space Separator</li> </ul> <p>Meta-character <code>\\p</code> denotes one Unicode char of specified category. Syntax: <code>\\pL</code> and <code>\\p{L}</code> for 1-letter name, <code>\\p{Lu}</code> for 2-letter names.</p> <p>Meta-character <code>\\P</code> is inverted, it denotes one Unicode char not in the specified category.</p> <p>These meta-characters are supported within character classes too.</p>"},{"location":"regular_expressions/#afterword","title":"Afterword","text":"<p>In this ancient blog post from previous century I illustrate some usages of regular expressions.</p>"},{"location":"tregexpr/","title":"TRegExpr","text":"<p>To use it, copy files \"regexpr.pas\", \"regexpr_unicodedata.pas\", \"regexpr_compilers.inc\", to your project folder.</p> <p>The library is already included into Lazarus (Free Pascal)  project so you do not need to copy anything if you use  Lazarus.</p>"},{"location":"tregexpr/#tregexpr-class","title":"TRegExpr class","text":""},{"location":"tregexpr/#versionmajor-versionminor","title":"VersionMajor, VersionMinor","text":"<p>Return major and minor version of the component.</p> <pre><code>VersionMajor = 1\nVersionMinor = 101\n</code></pre>"},{"location":"tregexpr/#expression","title":"Expression","text":"<p>Regular expression.</p> <p>For optimization, regular expression is automatically compiled into P-code. Human-readable form of the P-code is returned by Dump.</p> <p>In case of any errors in compilation, <code>Error</code> method is called (by default <code>Error</code> raises exception ERegExpr).</p>"},{"location":"tregexpr/#modifierstr","title":"ModifierStr","text":"<p>Set or get values of regular expression modifiers.</p> <p>Format of the string is similar to (?ismx-ismx). For example <code>ModifierStr := \u2018i-x\u2019</code> will switch on the modifier /i, switch off /x and leave unchanged others.</p> <p>If you try to set unsupported modifier, <code>Error</code> will be called.</p>"},{"location":"tregexpr/#modifieri","title":"ModifierI","text":"<p>Modifier /i, \"case-insensitive\", initialized with RegExprModifierI value.</p>"},{"location":"tregexpr/#modifierr","title":"ModifierR","text":"<p>Modifier /r, \"Russian range extension\", initialized with RegExprModifierR value.</p>"},{"location":"tregexpr/#modifiers","title":"ModifierS","text":"<p>Modifier /s, \"single line strings\", initialized with RegExprModifierS value.</p>"},{"location":"tregexpr/#modifierg","title":"ModifierG","text":"<p>Modifier /g, \"greediness\", initialized with RegExprModifierG value.</p>"},{"location":"tregexpr/#modifierm","title":"ModifierM","text":"<p>Modifier /m, \"multi-line strings\", initialized with RegExprModifierM value.</p>"},{"location":"tregexpr/#modifierx","title":"ModifierX","text":"<p>Modifier /x, \"eXtended syntax\", initialized with RegExprModifierX value.</p>"},{"location":"tregexpr/#exec","title":"Exec","text":"<p>Finds regular expression against <code>AInputString</code>, starting from the beginning.</p> <p>The overloaded <code>Exec</code> version without <code>AInputString</code> exists, it uses <code>AInputString</code> from previous call.</p> <p>See also global function ExecRegExpr that you can use without explicit <code>TRegExpr</code> object creation.</p>"},{"location":"tregexpr/#execnext","title":"ExecNext","text":"<p>Finds next match. If parameter <code>ABackward</code> is True, it goes downto position 1, ie runs backward search.</p> <p>Without parameter it works the same as:</p> <pre><code>if MatchLen [0] = 0\n  then ExecPos (MatchPos [0] + 1)\n  else ExecPos (MatchPos [0] + MatchLen [0]);\n</code></pre> <p>Raises exception if used without preceeding successful call to Exec, ExecPos or ExecNext.</p> <p>So you always must use something like:</p> <pre><code>if Exec(InputString)\n  then\n    repeat\n      { proceed results}\n    until not ExecNext;\n</code></pre>"},{"location":"tregexpr/#execpos","title":"ExecPos","text":"<p>Finds match for <code>AInputString</code> starting from <code>AOffset</code> position (1-based).</p> <p>Parameter <code>ABackward</code> means going from <code>AOffset</code> downto 1, ie backward search.</p> <p>Parameter <code>ATryOnce</code> means that testing for regex will be only at the initial position, without going to next/previous positions.</p>"},{"location":"tregexpr/#inputstring","title":"InputString","text":"<p>Returns current input string (from last Exec call or last assign to this property).</p> <p>Any assignment to this property clears Match, MatchPos and MatchLen.</p>"},{"location":"tregexpr/#substitute","title":"Substitute","text":"<pre><code>function Substitute (const ATemplate : RegExprString) : RegExprString;\n</code></pre> <p>Returns <code>ATemplate</code>, where <code>$&amp;</code> or <code>$0</code> are replaced with the found match, and <code>$1</code> to <code>$9</code> are replaced with found groups 1 to 9.</p> <p>To use in template the characters <code>$</code> or <code>\\</code>, escape them with a backslash <code>\\</code>, like <code>\\\\</code> or <code>\\$</code>.</p> Symbol Description <code>$&amp;</code> whole regular expression match <code>$0</code> whole regular expression match <code>$1</code> .. <code>$9</code> contents of numbered group 1 .. 9 <code>\\n</code> in Windows replaced with <code>\\r\\n</code> <code>\\l</code> lowercase one next char <code>\\L</code> lowercase all chars after that <code>\\u</code> uppercase one next char <code>\\U</code> uppercase all chars after that <pre><code>'1\\$ is $2\\\\rub\\\\' -&gt; '1$ is &lt;Match[2]&gt;\\rub\\'\n'\\U$1\\\\r' transforms into '&lt;Match[1] in uppercase&gt;\\r'\n</code></pre> <p>If you want to place raw digit after \u2018\\$n\u2019 you must delimit <code>n</code> with curly braces <code>{}</code>.</p> <pre><code>'a$12bc' -&gt; 'a&lt;Match[12]&gt;bc'\n'a${1}2bc' -&gt; 'a&lt;Match[1]&gt;2bc'.\n</code></pre> <p>To use found named groups, use syntax <code>${name}</code>, where \"name\" is valid identifier of previously found named group (starting with non-digit).</p>"},{"location":"tregexpr/#split","title":"Split","text":"<p>Splits <code>AInputStr</code> into <code>APieces</code> by regex occurrences.</p> <p>Internally calls Exec / ExecNext</p> <p>See also global function SplitRegExpr that you can use without explicit <code>TRegExpr</code> object creation.</p> <p></p>"},{"location":"tregexpr/#replace-replaceex","title":"Replace, ReplaceEx","text":"<pre><code>function Replace (Const AInputStr : RegExprString;\n  const AReplaceStr : RegExprString;\n  AUseSubstitution : boolean= False)\n : RegExprString; overload;\n\nfunction Replace (Const AInputStr : RegExprString;\n  AReplaceFunc : TRegExprReplaceFunction)\n : RegExprString; overload;\n\nfunction ReplaceEx (Const AInputStr : RegExprString;\n  AReplaceFunc : TRegExprReplaceFunction):\n  RegExprString;\n</code></pre> <p>Returns the string with regex occurencies replaced by the replace string.</p> <p>If last argument (<code>AUseSubstitution</code>) is true, then <code>AReplaceStr</code> will be used as template for Substitution methods.</p> <pre><code>Expression := '((?i)block|var)\\s*(\\s*\\([^ ]*\\)\\s*)\\s*';\nReplace ('BLOCK( test1)', 'def \"$1\" value \"$2\"', True);\n</code></pre> <p>Returns <code>def \"BLOCK\" value \"test1\"</code></p> <pre><code>Replace ('BLOCK( test1)', 'def \"$1\" value \"$2\"', False)\n</code></pre> <p>Returns\u00a0<code>def \"$1\" value \"$2\"</code></p> <p>Internally calls Exec / ExecNext</p> <p>Overloaded version and <code>ReplaceEx</code> operate with callback function, so you can implement really complex functionality.</p> <p>See also global function ReplaceRegExpr that you can use without explicit <code>TRegExpr</code> object creation.</p>"},{"location":"tregexpr/#subexprmatchcount","title":"SubExprMatchCount","text":"<p>Count of groups (subexpressions) found in last Exec / ExecNext call.</p> <p>If there are no groups found, but some string was found (Exec* returned True), it returns 0. If no groups nor some string were found (Exec / ExecNext returned false), it returns -1.</p> <p>Note, that some group may be not found, and for such group <code>MathPos=MatchLen=-1</code> and <code>Match=\u2019\u2019</code>.</p> <pre><code>Expression := '(1)?2(3)?';\nExec ('123'): SubExprMatchCount=2, Match[0]='123', [1]='1', [2]='3'\n\nExec ('12'): SubExprMatchCount=1, Match[0]='12', [1]='1'\n\nExec ('23'): SubExprMatchCount=2, Match[0]='23', [1]='', [2]='3'\n\nExec ('2'): SubExprMatchCount=0, Match[0]='2'\n\nExec ('7') - return False: SubExprMatchCount=-1\n</code></pre>"},{"location":"tregexpr/#matchpos","title":"MatchPos","text":"<p>Position (1-based) of group with specified index. Result is valid only after some match was found. First group has index 1, the entire match has index 0.</p> <p>Returns -1 if no group with specified index was found.</p>"},{"location":"tregexpr/#matchlen","title":"MatchLen","text":"<p>Length of group with specified index. Result is valid only after some match was found. First group has index 1, the entire match has index 0.</p> <p>Returns -1 if no group with specified index was found.</p>"},{"location":"tregexpr/#match","title":"Match","text":"<p>String of group with specified index. First group has index 1, the entire match has index 0. Returns empty string, if no such group was found.</p>"},{"location":"tregexpr/#matchindexfromname","title":"MatchIndexFromName","text":"<p>Returns group index (1-based) from group name, which is needed for \"named groups\". Returns -1 if no such named group was found.</p>"},{"location":"tregexpr/#lasterror","title":"LastError","text":"<p>Returns Id of last error, or 0 if no errors occured (unusable if <code>Error</code> method raises exception). It also clears internal status to 0 (no errors).</p>"},{"location":"tregexpr/#errormsg","title":"ErrorMsg","text":"<p>Returns <code>Error</code> message for error with <code>ID = AErrorID</code>.</p>"},{"location":"tregexpr/#compilererrorpos","title":"CompilerErrorPos","text":"<p>Returns position in regex, where P-code compilation was stopped.</p> <p>Useful for error diagnostics.</p>"},{"location":"tregexpr/#spacechars","title":"SpaceChars","text":"<p>Contains chars, treated as <code>\\s</code> (initially filled with RegExprSpaceChars global constant).</p>"},{"location":"tregexpr/#wordchars","title":"WordChars","text":"<p>Contains chars, treated as <code>\\w</code> (initially filled with RegExprWordChars global constant).</p>"},{"location":"tregexpr/#lineseparators","title":"LineSeparators","text":"<p>Line separators (like <code>\\n</code> in Unix), initially filled with RegExprLineSeparators global constant).</p> <p>See also Line Boundaries</p>"},{"location":"tregexpr/#uselinepairedbreak","title":"UseLinePairedBreak","text":"<p>Boolean property, enables to detect paired line separator CR LF.</p> <p>See also Line Boundaries</p> <p>For example, if you need only Unix-style separator LF, assign <code>LineSeparators := #$a</code> and <code>UseLinePairedBreak := False</code>.</p> <p>If you want to accept as line separators only CR LF but not CR or LF alone, then assign <code>LineSeparators := ''</code> (empty string) and <code>UseLinePairedBreak := True</code>.</p> <p>By default, \"mixed\" mode is used (defined in RegExprLineSeparators global constant):</p> <pre><code>LineSeparators := #$d#$a; \nUseLinePairedBreak := True;\n</code></pre> <p>Behaviour of this mode is described in the Line Boundaries.</p>"},{"location":"tregexpr/#compile","title":"Compile","text":"<p>Compiles regular expression to internal P-code.</p> <p>Useful for example for GUI regular expressions editors - to check regular expression without using it.</p>"},{"location":"tregexpr/#dump","title":"Dump","text":"<p>Shows P-code (compiled regular expression) as human-readable string.</p>"},{"location":"tregexpr/#global-constants","title":"Global constants","text":""},{"location":"tregexpr/#escchar","title":"EscChar","text":"<p>Escape character, by default backslash <code>'\\'</code>.</p>"},{"location":"tregexpr/#substitutegroupchar","title":"SubstituteGroupChar","text":"<p>Char used to prefix groups (numbered and named) in Substitute method, by default <code>'$'</code>.</p>"},{"location":"tregexpr/#regexprmodifieri","title":"RegExprModifierI","text":"<p>Modifier i default value.</p>"},{"location":"tregexpr/#regexprmodifierr","title":"RegExprModifierR","text":"<p>Modifier r default value.</p>"},{"location":"tregexpr/#regexprmodifiers","title":"RegExprModifierS","text":"<p>Modifier s default value.</p>"},{"location":"tregexpr/#regexprmodifierg","title":"RegExprModifierG","text":"<p>Modifier g default value.</p>"},{"location":"tregexpr/#regexprmodifierm","title":"RegExprModifierM","text":"<p>Modifier m default value.</p>"},{"location":"tregexpr/#regexprmodifierx","title":"RegExprModifierX","text":"<p>Modifier x default value.</p>"},{"location":"tregexpr/#regexprspacechars","title":"RegExprSpaceChars","text":"<p>Default for SpaceChars property.</p>"},{"location":"tregexpr/#regexprwordchars","title":"RegExprWordChars","text":"<p>Default value for WordChars property. \u00a0 RegExprLineSeparators \\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~~</p> <p>Default value for LineSeparators property.</p>"},{"location":"tregexpr/#global-functions","title":"Global functions","text":"<p>All this functionality is available as methods of <code>TRegExpr</code>, but with global functions you do not need to create <code>TReExpr</code> instance so your code would be more simple if you just need one function.</p>"},{"location":"tregexpr/#execregexpr","title":"ExecRegExpr","text":"<p>Returns True if the string matches the regular expression. Just like Exec in <code>TRegExpr</code>.</p>"},{"location":"tregexpr/#splitregexpr","title":"SplitRegExpr","text":"<p>Splits the string by regular expression occurences. See also Split if you prefer to create <code>TRegExpr</code> instance explicitly.</p>"},{"location":"tregexpr/#replaceregexpr","title":"ReplaceRegExpr","text":"<pre><code>function ReplaceRegExpr (\n    const ARegExpr, AInputStr, AReplaceStr : RegExprString;\n    AUseSubstitution : boolean= False\n) : RegExprString; overload;\n\nType\n  TRegexReplaceOption = (rroModifierI,\n                         rroModifierR,\n                         rroModifierS,\n                         rroModifierG,\n                         rroModifierM,\n                         rroModifierX,\n                         rroUseSubstitution,\n                         rroUseOsLineEnd);\n  TRegexReplaceOptions = Set of TRegexReplaceOption;\n\nfunction ReplaceRegExpr (\n    const ARegExpr, AInputStr, AReplaceStr : RegExprString;\n    Options :TRegexReplaceOptions\n) : RegExprString; overload;\n</code></pre> <p>Returns the string with regular expressions replaced by the <code>AReplaceStr</code>. See also Replace if you prefer to create TRegExpr instance explicitly.</p> <p>If last argument (<code>AUseSubstitution</code>) is True, then <code>AReplaceStr</code> will be used as template for <code>Substitution methods</code>:</p> <pre><code>ReplaceRegExpr (\n  '((?i)block|var)\\s*(\\s*\\([^ ]*\\)\\s*)\\s*',\n  'BLOCK(test1)',\n  'def \"$1\" value \"$2\"',\n  True\n)\n</code></pre> <p>Returns <code>def 'BLOCK' value 'test1'</code></p> <p>But this one (note there is no last argument):</p> <pre><code>ReplaceRegExpr (\n  '((?i)block|var)\\s*(\\s*\\([^ ]*\\)\\s*)\\s*',\n  'BLOCK(test1)',\n  'def \"$1\" value \"$2\"'\n)\n</code></pre> <p>Returns <code>def \"$1\" value \"$2\"</code></p>"},{"location":"tregexpr/#version-with-options","title":"Version with options","text":"<p>With <code>Options</code> you control <code>\\n</code> behaviour (if <code>rroUseOsLineEnd</code> then <code>\\n</code> is replaced with <code>\\n\\r</code> in Windows and <code>\\n</code> in Linux). And so on.</p> <pre><code>Type\n  TRegexReplaceOption = (rroModifierI,\n                         rroModifierR,\n                         rroModifierS,\n                         rroModifierG,\n                         rroModifierM,\n                         rroModifierX,\n                         rroUseSubstitution,\n                         rroUseOsLineEnd);\n</code></pre>"},{"location":"tregexpr/#quoteregexprmetachars","title":"QuoteRegExprMetaChars","text":"<p>Replace all metachars with its safe representation, for example <code>abc'cd.(</code> is converted to <code>abc\\'cd\\.\\(</code></p> <p>This function is useful for regex auto-generation from user input.</p>"},{"location":"tregexpr/#regexprsubexpressions","title":"RegExprSubExpressions","text":"<p>Makes list of subexpressions found in <code>ARegExpr</code>.</p> <p>In <code>ASubExps</code> every item represents subexpression, from first to last, in format:</p> <p>String - subexpression text (without \u2018()\u2019)</p> <p>Low word of Object - starting position in ARegExpr, including \u2018(\u2019 if exists! (first position is 1)</p> <p>High word of Object - length, including starting \u2018(\u2019 and ending \u2018)\u2019 if exist!</p> <p><code>AExtendedSyntax</code> - must be True if modifier <code>/x</code> os on, while using the regex.</p> <p>Usefull for GUI editors of regex (you can find example of usage in REStudioMain.pas)</p> <p>=========== ======= Result code Meaning =========== ======= 0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Success. No unbalanced brackets were found. -1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Not enough closing brackets <code>)</code>. -(n+1) \u00a0 \u00a0 \u00a0At position n it was found opening <code>[</code> without corresponding closing <code>]</code>. n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 At position n it was found closing bracket <code>)</code> without corresponding opening <code>(</code>. =========== =======\u00a0</p> <p>If <code>Result &lt;&gt; 0</code>, then <code>ASubExprs</code> can contain empty items or illegal ones.</p>"},{"location":"tregexpr/#eregexpr","title":"ERegExpr","text":"<pre><code>ERegExpr = class (Exception)\n\u00a0 public\n\u00a0 \u00a0ErrorCode : integer; // error code. Compilation error codes are before 1000\n\u00a0 \u00a0CompilerErrorPos : integer; // Position in r.e. where compilation error occured\n\u00a0end;\n</code></pre>"},{"location":"tregexpr/#unicode","title":"Unicode","text":"<p>In Unicode mode, all strings (InputString, Expression, internal strings) are of type UnicodeString/WideString, instead of simple \"string\". Unicode slows down performance, so use it only if you really need Unicode support.</p> <p>To use Unicode, uncomment <code>{$DEFINE UniCode}</code> in regexpr.pas (remove <code>off</code>).</p>"}]}